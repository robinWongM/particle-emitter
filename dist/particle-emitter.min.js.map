{"version":3,"file":"dist/particle-emitter.min.js.map","names":["PolygonalChain","constructor","data","this","segments","countingLengths","totalLength","init","length","Array","isArray","i","chain","prevPoint","j","second","push","p1","p2","l","x","y","segLength","Math","sqrt","getRandPos","out","rand","random","chosenSeg","lerp","type","editorConfig","Rectangle","config","w","h","particle","PropertyNode","value","time","ease","next","isStepped","generateEase","static","array","list","node","first","hexToRGB","start","end","GetTextureFromString","Texture","from","verbose","DEG_TO_RADS","PI","rotatePoint","angle","p","s","sin","c","cos","xnew","ynew","combineRGBComponents","r","g","b","point","normalize","oneOverLen","scaleBy","color","output","alpha","charAt","substr","indexOf","parseInt","a","qty","oneOverQty","t","cp","e","name","numSteps","currentNode","current","nextIndex","curVal","nextVal","Torus","radius","innerRadius","rotation","affectRotation","position","BehaviorOrder","AccelerationBehavior","order","Late","minStart","maxStart","accel","rotate","maxSpeed","_a","initParticles","speed","velocity","set","Point","updateParticle","deltaSec","vel","oldVX","oldVY","currentSpeed","atan2","intValueSimple","intColorSimple","intValueComplex","intColorComplex","intValueStepped","intColorStepped","PropertyList","isColor","interpolate","reset","AlphaBehavior","Normal","createList","agePercent","StaticAlphaBehavior","getTextures","textures","outTextures","tex","dupe","count","texture","RandomAnimatedTextureBehavior","anims","anim","framerate","parsedAnim","duration","loop","index","floor","animElapsed","animDuration","maxLife","animFramerate","frame","EMPTY","SingleAnimatedTextureBehavior","BlendModeBehavior","blendMode","BurstSpawnBehavior","Spawn","spacing","distance","ColorBehavior","tint","StaticColorBehavior","OrderedTextureBehavior","map","helperPoint","MATH_FUNCS","WHITELISTER","RegExp","concat","join","PathBehavior","path","pathString","matches","match","Function","parsePath","minMult","initRotation","initPosition","copyFrom","movement","mult","speedMult","PointSpawnBehavior","_first","RandomTextureBehavior","RotationBehavior","minSpeed","rotSpeed","oldSpeed","StaticRotationBehavior","min","max","NoRotationBehavior","ScaleBehavior","scale","scaleMult","StaticScaleBehavior","ShapeSpawnBehavior","typeOverride","shapes","ShapeClass","Error","shape","registerShape","SingleTextureBehavior","SpeedBehavior","StaticSpeedBehavior","Particle","Sprite","emitter","super","prevChild","nextChild","anchor","age","oneOverLife","prev","kill","visible","recycle","destroy","parent","removeChild","ticker","Ticker","shared","PositionParticle","Symbol","Emitter","knownBehaviors","particleParent","initBehaviors","updateBehaviors","recycleBehaviors","minLifetime","maxLifetime","customEase","_frequency","spawnChance","maxParticles","emitterLifetime","spawnPos","particlesPerWave","ownerPos","_prevEmitterPos","_prevPosIsValid","_posChanged","_parent","addAtBack","particleCount","_emit","_spawnTimer","_emitterLife","_activeParticlesFirst","_activeParticlesLast","_poolFirst","_origConfig","_autoUpdate","_destroyWhenComplete","_completeCallback","update","updateSpawnPos","updateOwnerPos","frequency","cleanup","lifetime","pos","emit","undefined","autoUpdate","behaviors","console","error","filter","sort","slice","recycleParticle","getBehavior","find","fillPool","fromCleanup","newRot","diff","resetPositionTracking","remove","add","playOnceAndDestroy","callback","playOnce","prevX","prevY","delta","deltaTime","elapsedMS","curX","curY","emitPosX","emitPosY","waveFirst","waveLast","len","addChildAt","addChild","behavior","cb","emitNow","destroyed","registerBehavior","behaviors.AccelerationBehavior","behaviors.AlphaBehavior","behaviors.StaticAlphaBehavior","behaviors.RandomAnimatedTextureBehavior","behaviors.SingleAnimatedTextureBehavior","behaviors.BlendModeBehavior","behaviors.BurstSpawnBehavior","behaviors.ColorBehavior","behaviors.StaticColorBehavior","behaviors.OrderedTextureBehavior","behaviors.PathBehavior","behaviors.PointSpawnBehavior","behaviors.RandomTextureBehavior","behaviors.RotationBehavior","behaviors.StaticRotationBehavior","behaviors.NoRotationBehavior","behaviors.ScaleBehavior","behaviors.StaticScaleBehavior","behaviors.ShapeSpawnBehavior","behaviors.SingleTextureBehavior","behaviors.SpeedBehavior","behaviors.StaticSpeedBehavior","art","acceleration","minimumSpeedMultiplier","_b","noRotation","_c","extraData","_d","_e","_f","_g","_h","_j","minimumScaleMultiplier","_k","_l","rotationAcceleration","_m","rotationSpeed","_o","_p","_q","_r","startRotation","_s","_t","_u","_v","_w","orderedArt","spawnType","angleStart","particleSpacing","spawnCircle","minR","spawnRect","spawnPolygon"],"sources":["../src/behaviors/shapes/PolygonalChain.ts","../src/behaviors/shapes/Rectangle.ts","../src/PropertyNode.ts","../src/ParticleUtils.ts","../src/behaviors/shapes/Torus.ts","../src/behaviors/Behaviors.ts","../src/behaviors/AccelerationMovement.ts","../src/PropertyList.ts","../src/behaviors/Alpha.ts","../src/behaviors/AnimatedTexture.ts","../src/behaviors/BlendMode.ts","../src/behaviors/BurstSpawn.ts","../src/behaviors/Color.ts","../src/behaviors/OrderedTexture.ts","../src/behaviors/PathMovement.ts","../src/behaviors/PointSpawn.ts","../src/behaviors/RandomTexture.ts","../src/behaviors/Rotation.ts","../src/behaviors/Scale.ts","../src/behaviors/ShapeSpawn.ts","../src/behaviors/SingleTexture.ts","../src/behaviors/SpeedMovement.ts","../src/Particle.ts","../src/Emitter.ts","../src/index.ts","../src/EmitterConfig.ts"],"sourcesContent":["import { PointData } from 'pixi.js';\nimport { ListProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\n/**\n * Data structure for internal parsed data in PolygonalChain spawn shapes.\n */\nexport interface Segment\n{\n    p1: PointData;\n    p2: PointData;\n    l: number;\n}\n\n/**\n * A spawn shape that picks a random position along a series of line segments. If those\n * line segments form a polygon, particles will only be placed on the perimeter of that polygon.\n *\n * Example config:\n * ```javascript\n * {\n *      type: 'polygonalChain',\n *      data: [\n *          [{x: 0, y: 0}, {x: 10, y: 10}, {x: 20, y: 0}],\n *          [{x: 0, y, -10}, {x: 10, y: 0}, {x: 20, y: -10}]\n *      ]\n * }\n * ```\n */\nexport class PolygonalChain implements SpawnShape\n{\n    public static type = 'polygonalChain';\n    public static editorConfig: ListProperty = null;\n    /**\n     * List of segment objects in the chain.\n     */\n    private segments: Segment[];\n    /**\n     * Total length of all segments of the chain.\n     */\n    private totalLength: number;\n    /**\n     * Total length of segments up to and including the segment of the same index.\n     * Used for weighted random selection of segment.\n     */\n    private countingLengths: number[];\n\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    constructor(data: PointData[] | PointData[][])\n    {\n        this.segments = [];\n        this.countingLengths = [];\n        this.totalLength = 0;\n        this.init(data);\n    }\n\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    private init(data: PointData[] | PointData[][]): void\n    {\n        // if data is not present, set up a segment of length 0\n        if (!data || !data.length)\n        {\n            this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 });\n        }\n        else if (Array.isArray(data[0]))\n        {\n            // list of segment chains, each defined as a list of points\n            for (let i = 0; i < data.length; ++i)\n            {\n                // loop through the chain, connecting points\n                const chain = data[i] as PointData[];\n                let prevPoint = chain[0] as PointData;\n\n                for (let j = 1; j < chain.length; ++j)\n                {\n                    const second = chain[j] as PointData;\n\n                    this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                    prevPoint = second;\n                }\n            }\n        }\n        else\n        {\n            let prevPoint = data[0] as PointData;\n            // list of points\n\n            for (let i = 1; i < data.length; ++i)\n            {\n                const second = data[i] as PointData;\n\n                this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                prevPoint = second;\n            }\n        }\n        // now go through our segments to calculate the lengths so that we\n        // can set up a nice weighted random distribution\n        for (let i = 0; i < this.segments.length; ++i)\n        {\n            const { p1, p2 } = this.segments[i];\n            const segLength = Math.sqrt(((p2.x - p1.x) * (p2.x - p1.x)) + ((p2.y - p1.y) * (p2.y - p1.y)));\n            // save length so we can turn a random number into a 0-1 interpolation value later\n\n            this.segments[i].l = segLength;\n            this.totalLength += segLength;\n            // keep track of the length so far, counting up\n            this.countingLengths.push(this.totalLength);\n        }\n    }\n\n    /**\n     * Gets a random point in the chain.\n     * @param out The point to store the selected position in.\n     */\n    public getRandPos(out: PointData): void\n    {\n        // select a random spot in the length of the chain\n        const rand = Math.random() * this.totalLength;\n        let chosenSeg: Segment;\n        let lerp: number;\n\n        // if only one segment, it wins\n        if (this.segments.length === 1)\n        {\n            chosenSeg = this.segments[0];\n            lerp = rand;\n        }\n        else\n        {\n            // otherwise, go through countingLengths until we have determined\n            // which segment we chose\n            for (let i = 0; i < this.countingLengths.length; ++i)\n            {\n                if (rand < this.countingLengths[i])\n                {\n                    chosenSeg = this.segments[i];\n                    // set lerp equal to the length into that segment\n                    // (i.e. the remainder after subtracting all the segments before it)\n                    lerp = i === 0 ? rand : rand - this.countingLengths[i - 1];\n                    break;\n                }\n            }\n        }\n        // divide lerp by the segment length, to result in a 0-1 number.\n        lerp /= chosenSeg.l || 1;\n        const { p1, p2 } = chosenSeg;\n        // now calculate the position in the segment that the lerp value represents\n\n        out.x = p1.x + (lerp * (p2.x - p1.x));\n        out.y = p1.y + (lerp * (p2.y - p1.y));\n    }\n}\n","import { Particle } from '../../Particle';\nimport { SpawnShape } from './SpawnShape';\n\nimport type { ObjectProperty } from '../editor/Types';\n\n/**\n * A SpawnShape that randomly picks locations inside a rectangle.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'rect',\n *     data: {\n *          x: 0,\n *          y: 0,\n *          w: 10,\n *          h: 100\n *     }\n * }\n * ```\n */\nexport class Rectangle implements SpawnShape\n{\n    public static type = 'rect';\n    public static editorConfig: ObjectProperty = null;\n    /**\n     * X (left) position of the rectangle.\n     */\n    public x: number;\n    /**\n     * Y (top) position of the rectangle.\n     */\n    public y: number;\n    /**\n     * Width of the rectangle.\n     */\n    public w: number;\n    /**\n     * Height of the rectangle.\n     */\n    public h: number;\n\n    constructor(config: {\n        /**\n         * X (left) position of the rectangle.\n         */\n        x: number;\n        /**\n         * Y (top) position of the rectangle.\n         */\n        y: number;\n        /**\n         * Width of the rectangle.\n         */\n        w: number;\n        /**\n         * Height of the rectangle.\n         */\n        h: number;\n    })\n    {\n        this.x = config.x;\n        this.y = config.y;\n        this.w = config.w;\n        this.h = config.h;\n    }\n\n    getRandPos(particle: Particle): void\n    {\n        // place the particle at a random point in the rectangle\n        particle.x = (Math.random() * this.w) + this.x;\n        particle.y = (Math.random() * this.h) + this.y;\n    }\n}\n","import { BasicTweenable } from './EmitterConfig';\nimport { Color, EaseSegment, generateEase, hexToRGB, SimpleEase } from './ParticleUtils';\n\n/**\n * A single step of a ValueList.\n */\nexport interface ValueStep<T>\n{\n    /**\n     * The color or number to use at this step.\n     */\n    value: T;\n    /**\n     * The percentage time of the particle's lifespan that this step happens at.\n     * Values are between 0 and 1, inclusive.\n     */\n    time: number;\n}\n\n/**\n * Configuration for an interpolated or stepped list of numeric or color particle values.\n */\nexport interface ValueList<T>\n{\n    /**\n     * The ordered list of values.\n     */\n    list: ValueStep<T>[];\n    /**\n     * If the list is stepped. Stepped lists don't determine any in-between values, instead sticking with each value\n     * until its time runs out.\n     */\n    isStepped?: boolean;\n    /**\n     * Easing that should be applied to this list, in order to alter how quickly the steps progress.\n     */\n    ease?: SimpleEase | EaseSegment[];\n}\n/**\n * A single node in a PropertyList.\n */\nexport class PropertyNode<V>\n{\n    /**\n     * Value for the node.\n     */\n    public value: V;\n    /**\n     * Time value for the node. Between 0-1.\n     */\n    public time: number;\n    /**\n     * The next node in line.\n     */\n    public next: PropertyNode<V>;\n    /**\n     * If this is the first node in the list, controls if the entire list is stepped or not.\n     */\n    public isStepped: boolean;\n    public ease: SimpleEase;\n\n    /**\n     * @param value The value for this node\n     * @param time The time for this node, between 0-1\n     * @param [ease] Custom ease for this list. Only relevant for the first node.\n     */\n    constructor(value: V, time: number, ease?: SimpleEase | EaseSegment[])\n    {\n        this.value = value;\n        this.time = time;\n        this.next = null;\n        this.isStepped = false;\n        if (ease)\n        {\n            this.ease = typeof ease === 'function' ? ease : generateEase(ease);\n        }\n        else\n        {\n            this.ease = null;\n        }\n    }\n\n    /**\n     * Creates a list of property values from a data object {list, isStepped} with a list of objects in\n     * the form {value, time}. Alternatively, the data object can be in the deprecated form of\n     * {start, end}.\n     * @param data The data for the list.\n     * @param data.list The array of value and time objects.\n     * @param data.isStepped If the list is stepped rather than interpolated.\n     * @param data.ease Custom ease for this list.\n     * @return The first node in the list\n     */\n    // eslint-disable-next-line max-len\n    public static createList<T extends(string | number)>(data: ValueList<T> | BasicTweenable<T>): PropertyNode<T extends string ? Color : T>\n    {\n        if ('list' in data)\n        {\n            const array = data.list;\n            let node;\n            const { value, time } = array[0];\n\n            // eslint-disable-next-line max-len\n            const first = node = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time, data.ease);\n\n            // only set up subsequent nodes if there are a bunch or the 2nd one is different from the first\n            if (array.length > 2 || (array.length === 2 && array[1].value !== value))\n            {\n                for (let i = 1; i < array.length; ++i)\n                {\n                    const { value, time } = array[i];\n\n                    node.next = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time);\n                    node = node.next;\n                }\n            }\n            first.isStepped = !!data.isStepped;\n\n            return first as PropertyNode<T extends string ? Color : T>;\n        }\n\n        // Handle deprecated version here\n        const start = new PropertyNode(typeof data.start === 'string' ? hexToRGB(data.start) : data.start, 0);\n        // only set up a next value if it is different from the starting value\n\n        if (data.end !== data.start)\n        {\n            start.next = new PropertyNode(typeof data.end === 'string' ? hexToRGB(data.end) : data.end, 1);\n        }\n\n        return start as PropertyNode<T extends string ? Color : T>;\n    }\n}\n","import { BLEND_MODES, PointData, Texture } from 'pixi.js';\nimport { PropertyNode, ValueStep } from './PropertyNode';\n\n/**\n * The method used by behaviors to fetch textures. Defaults to Texture.from.\n */\n// get Texture.from(), only supports V5 and V6 with individual packages\n// eslint-disable-next-line prefer-const\nexport let GetTextureFromString:(d:string) => Texture = Texture.from;\n\n/**\n * A color value, split apart for interpolation.\n */\nexport interface Color\n{\n    r: number;\n    g: number;\n    b: number;\n    a?: number;\n}\n\nexport interface EaseSegment\n{\n    cp: number;\n    s: number;\n    e: number;\n}\n\n/**\n * The basic easing function used. Takes in a value between 0-1, and outputs another value between 0-1.\n * For example, a basic quadratic in ease would be `(time) => time * time`\n */\nexport type SimpleEase = (time: number) => number;\n\n/**\n * If errors and warnings should be logged within the library.\n */\nexport const verbose = false;\n\nexport const DEG_TO_RADS = Math.PI / 180;\n\n/**\n * Rotates a point by a given angle.\n * @param angle The angle to rotate by in radians\n * @param p The point to rotate around 0,0.\n */\nexport function rotatePoint(angle: number, p: PointData): void\n{\n    if (!angle) return;\n\n    const s = Math.sin(angle);\n    const c = Math.cos(angle);\n    const xnew = (p.x * c) - (p.y * s);\n    const ynew = (p.x * s) + (p.y * c);\n\n    p.x = xnew;\n    p.y = ynew;\n}\n\n/**\n * Combines separate color components (0-255) into a single uint color.\n * @param r The red value of the color\n * @param g The green value of the color\n * @param b The blue value of the color\n * @return The color in the form of 0xRRGGBB\n */\nexport function combineRGBComponents(r: number, g: number, b: number/* , a*/): number\n{\n    return /* a << 24 |*/ (r << 16) | (g << 8) | b;\n}\n\n/**\n * Returns the length (or magnitude) of this point.\n * @param point The point to measure length\n * @return The length of this point.\n */\nexport function length(point: PointData): number\n{\n    return Math.sqrt((point.x * point.x) + (point.y * point.y));\n}\n\n/**\n * Reduces the point to a length of 1.\n * @param point The point to normalize\n */\nexport function normalize(point: PointData): void\n{\n    const oneOverLen = 1 / length(point);\n\n    point.x *= oneOverLen;\n    point.y *= oneOverLen;\n}\n\n/**\n * Multiplies the x and y values of this point by a value.\n * @param point The point to scaleBy\n * @param value The value to scale by.\n */\nexport function scaleBy(point: PointData, value: number): void\n{\n    point.x *= value;\n    point.y *= value;\n}\n\n/**\n * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\n * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\n * {r, g, b, (a)}.\n * @param color The input color string.\n * @param output An object to put the output in. If omitted, a new object is created.\n * @return The object with r, g, and b properties, possibly with an a property.\n */\nexport function hexToRGB(color: string, output?: Color): Color\n{\n    if (!output)\n    {\n        output = {} as Color;\n    }\n    if (color.charAt(0) === '#')\n    {\n        color = color.substr(1);\n    }\n    else if (color.indexOf('0x') === 0)\n    {\n        color = color.substr(2);\n    }\n    let alpha;\n\n    if (color.length === 8)\n    {\n        alpha = color.substr(0, 2);\n        color = color.substr(2);\n    }\n    output.r = parseInt(color.substr(0, 2), 16);// Red\n    output.g = parseInt(color.substr(2, 2), 16);// Green\n    output.b = parseInt(color.substr(4, 2), 16);// Blue\n    if (alpha)\n    {\n        output.a = parseInt(alpha, 16);\n    }\n\n    return output;\n}\n\n/**\n * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\n * by the related tool at http://www.greensock.com/customease/.\n * @param segments An array of segments, as created by\n * http://www.greensock.com/customease/.\n * @return A function that calculates the percentage of change at\n *                    a given point in time (0-1 inclusive).\n */\nexport function generateEase(segments: EaseSegment[]): SimpleEase\n{\n    const qty = segments.length;\n    const oneOverQty = 1 / qty;\n    /*\n        * Calculates the percentage of change at a given point in time (0-1 inclusive).\n        * @param {Number} time The time of the ease, 0-1 inclusive.\n        * @return {Number} The percentage of the change, 0-1 inclusive (unless your\n        *                  ease goes outside those bounds).\n        */\n\n    // eslint-disable-next-line func-names\n    return function (time: number): number\n    {\n        const i = (qty * time) | 0;// do a quick floor operation\n\n        const t = (time - (i * oneOverQty)) * qty;\n        const s = segments[i] || segments[qty - 1];\n\n        return (s.s + (t * ((2 * (1 - t) * (s.cp - s.s)) + (t * (s.e - s.s)))));\n    };\n}\n\n/**\n * Gets a blend mode, ensuring that it is valid.\n * @param name The name of the blend mode to get.\n * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.\n */\nexport function getBlendMode(name?: BLEND_MODES): BLEND_MODES\n{\n    if (!name) return 'normal';\n\n    return name;\n}\n\n/**\n * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\n * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\n * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\n * @param list The list of data to convert.\n * @param [numSteps=10] The number of steps to use.\n * @return The blend mode as specified in the PIXI.blendModes enumeration.\n */\nexport function createSteppedGradient(list: ValueStep<string>[], numSteps = 10): PropertyNode<Color>\n{\n    if (typeof numSteps !== 'number' || numSteps <= 0)\n    {\n        numSteps = 10;\n    }\n    const first = new PropertyNode<Color>(hexToRGB(list[0].value), list[0].time);\n\n    first.isStepped = true;\n    let currentNode = first;\n    let current = list[0];\n    let nextIndex = 1;\n    let next = list[nextIndex];\n\n    for (let i = 1; i < numSteps; ++i)\n    {\n        let lerp = i / numSteps;\n        // ensure we are on the right segment, if multiple\n\n        while (lerp > next.time)\n        {\n            current = next;\n            next = list[++nextIndex];\n        }\n        // convert the lerp value to the segment range\n        lerp = (lerp - current.time) / (next.time - current.time);\n        const curVal = hexToRGB(current.value);\n        const nextVal = hexToRGB(next.value);\n        const output: Color = {\n            r: ((nextVal.r - curVal.r) * lerp) + curVal.r,\n            g: ((nextVal.g - curVal.g) * lerp) + curVal.g,\n            b: ((nextVal.b - curVal.b) * lerp) + curVal.b,\n        };\n\n        currentNode.next = new PropertyNode(output, i / numSteps);\n        currentNode = currentNode.next;\n    }\n\n    // we don't need to have a PropertyNode for time of 1, because in a stepped version at that point\n    // the particle has died of old age\n    return first;\n}\n","import { Particle } from '../../Particle';\nimport { rotatePoint } from '../../ParticleUtils';\nimport { ObjectProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\n/**\n * A class for spawning particles in a circle or ring.\n * Can optionally apply rotation to particles so that they are aimed away from the center of the circle.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'torus',\n *     data: {\n *          radius: 30,\n *          x: 0,\n *          y: 0,\n *          innerRadius: 10,\n *          rotation: true\n *     }\n * }\n * ```\n */\nexport class Torus implements SpawnShape\n{\n    public static type = 'torus';\n    public static editorConfig: ObjectProperty = null;\n    /**\n     * X position of the center of the shape.\n     */\n    public x: number;\n    /**\n     * Y position of the center of the shape.\n     */\n    public y: number;\n    /**\n     * Radius of circle, or outer radius of a ring.\n     */\n    public radius: number;\n    /**\n     * Inner radius of a ring. Use 0 to have a circle.\n     */\n    public innerRadius: number;\n    /**\n     * If rotation should be applied to particles.\n     */\n    public rotation: boolean;\n\n    constructor(config: {\n        /**\n         * Radius of circle, or outer radius of a ring. Note that this uses the full name of 'radius',\n         * where earlier versions of the library may have used 'r'.\n         */\n        radius: number;\n        /**\n         * X position of the center of the shape.\n         */\n        x: number;\n        /**\n         * Y position of the center of the shape.\n         */\n        y: number;\n        /**\n         * Inner radius of a ring. Omit, or use 0, to have a circle.\n         */\n        innerRadius?: number;\n        /**\n         * If rotation should be applied to particles, pointing them away from the center of the torus.\n         * Defaults to false.\n         */\n        affectRotation?: boolean\n    })\n    {\n        this.x = config.x || 0;\n        this.y = config.y || 0;\n        this.radius = config.radius;\n        this.innerRadius = config.innerRadius || 0;\n        this.rotation = !!config.affectRotation;\n    }\n\n    getRandPos(particle: Particle): void\n    {\n        // place the particle at a random radius in the ring\n        if (this.innerRadius !== this.radius)\n        {\n            particle.x = (Math.random() * (this.radius - this.innerRadius)) + this.innerRadius;\n        }\n        else\n        {\n            particle.x = this.radius;\n        }\n        particle.y = 0;\n        // rotate the point to a random angle in the circle\n        const angle = Math.random() * Math.PI * 2;\n\n        if (this.rotation)\n        {\n            particle.rotation += angle;\n        }\n        rotatePoint(angle, particle.position);\n        // now add in the center of the torus\n        particle.position.x += this.x;\n        particle.position.y += this.y;\n    }\n}\n","import { Particle } from '../Particle';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * All behaviors instances must implement this interface, and the class must match the\n * {@link IEmitterBehaviorClass} interface. All behaviors must have an order property and\n * `initParticles` method. Implementing the `updateParticle` or `recycleParticle` methods is optional.\n */\nexport interface IEmitterBehavior\n{\n    /**\n     * Order in which the behavior will be handled. Lower numbers are handled earlier, with an order of 0 getting\n     * special treatment before the Emitter's transformation is applied.\n     */\n    order: number;\n    /**\n     * Called to initialize a wave of particles, with a reference to the first particle in the linked list.\n     * @param first The first (maybe only) particle in a newly spawned wave of particles.\n     */\n    initParticles(first: Particle): void;\n    /**\n     * Updates a single particle for a given period of time elapsed. Return `true` to recycle the particle.\n     * @param particle The particle to update.\n     * @param deltaSec The time to advance the particle by in seconds.\n     */\n    updateParticle?(particle: Particle, deltaSec: number): void | boolean;\n    /**\n     * A hook for when a particle is recycled.\n     * @param particle The particle that was just recycled.\n     * @param natural `true` if the reycling was due to natural lifecycle, `false` if it was due to emitter cleanup.\n     */\n    recycleParticle?(particle: Particle, natural: boolean): void;\n}\n\n/**\n * All behavior classes must match this interface. The instances need to implement the {@link IEmitterBehavior} interface.\n */\nexport interface IEmitterBehaviorClass\n{\n    /**\n     * The unique type name that the behavior is registered under.\n     */\n    type: string;\n    /**\n     * Configuration data for an editor to display this behavior. Does not need to exist in production code.\n     */\n    editorConfig?: BehaviorEditorConfig;\n    /**\n     * The behavior constructor itself.\n     * @param config The config for the behavior, which should match its defined specifications.\n     */\n    new (config: any): IEmitterBehavior;\n}\n\n/**\n * Standard behavior order values, specifying when/how they are used. Other numeric values can be used,\n * but only the Spawn value will be handled in a special way. All other values will be sorted numerically.\n * Behaviors with the same value will not be given any specific sort order, as they are assumed to not\n * interfere with each other.\n */\nexport enum BehaviorOrder\n    {\n    /**\n     * Spawn - initial placement and/or rotation. This happens before rotation/translation due to\n     * emitter rotation/position is applied.\n     */\n    Spawn = 0,\n    /**\n     * Normal priority, for things that don't matter when they are applied.\n     */\n    Normal = 2,\n    /**\n     * Delayed priority, for things that need to read other values in order to act correctly.\n     */\n    Late = 5,\n}\n","import { Point } from 'pixi.js';\nimport { Particle } from '../Particle';\nimport { length, rotatePoint, scaleBy } from '../ParticleUtils';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Movement behavior that handles movement by applying a constant acceleration to all particles.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"moveAcceleration\",\n *     \"config\": {\n *          \"accel\": {\n *               \"x\": 0,\n *               \"y\": 2000\n *          },\n *          \"minStart\": 600,\n *          \"maxStart\": 600,\n *          \"rotate\": true\n *     }\n *}\n * ```\n */\nexport class AccelerationBehavior implements IEmitterBehavior\n{\n    public static type = 'moveAcceleration';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    // doesn't _really_ need to be late, but doing so ensures that we can override any\n    // rotation behavior that is mistakenly added\n    public order = BehaviorOrder.Late;\n    private minStart: number;\n    private maxStart: number;\n    private accel: {x: number; y: number};\n    private rotate: boolean;\n    private maxSpeed: number;\n    constructor(config: {\n        /**\n         * Minimum speed when initializing the particle, in world units/second.\n         */\n        minStart: number;\n        /**\n         * Maximum speed when initializing the particle. in world units/second.\n         */\n        maxStart: number;\n        /**\n         * Constant acceleration, in the coordinate space of the particle parent, in world units/second.\n         */\n        accel: {x: number; y: number};\n        /**\n         * Rotate the particle with its direction of movement.\n         * While initial movement direction reacts to rotation settings, this overrides any dynamic rotation.\n         * Defaults to false.\n         */\n        rotate?: boolean;\n        /**\n         * Maximum linear speed. 0 is unlimited. Defaults to 0.\n         */\n        maxSpeed?: number;\n    })\n    {\n        this.minStart = config.minStart;\n        this.maxStart = config.maxStart;\n        this.accel = config.accel;\n        this.rotate = !!config.rotate;\n        this.maxSpeed = config.maxSpeed ?? 0;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const speed = (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(speed, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const vel = particle.config.velocity;\n        const oldVX = vel.x;\n        const oldVY = vel.y;\n\n        vel.x += this.accel.x * deltaSec;\n        vel.y += this.accel.y * deltaSec;\n        if (this.maxSpeed)\n        {\n            const currentSpeed = length(vel);\n            // if we are going faster than we should, clamp at the max speed\n            // DO NOT recalculate vector length\n\n            if (currentSpeed > this.maxSpeed)\n            {\n                scaleBy(vel, this.maxSpeed / currentSpeed);\n            }\n        }\n        // calculate position delta by the midpoint between our old velocity and our new velocity\n        particle.x += (oldVX + vel.x) / 2 * deltaSec;\n        particle.y += (oldVY + vel.y) / 2 * deltaSec;\n        if (this.rotate)\n        {\n            particle.rotation = Math.atan2(vel.y, vel.x);\n        }\n    }\n}\n","import { Color, combineRGBComponents, SimpleEase } from './ParticleUtils';\nimport { PropertyNode } from './PropertyNode';\n\nfunction intValueSimple(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    return ((this.first.next.value - this.first.value) * lerp) + this.first.value;\n}\n\nfunction intColorSimple(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    const curVal = this.first.value;\n    const nextVal = this.first.next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n\n    return combineRGBComponents(r, g, b);\n}\n\nfunction intValueComplex(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n\n    while (lerp > next.time)\n    {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n\n    return ((next.value - current.value) * lerp) + current.value;\n}\n\nfunction intColorComplex(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n\n    while (lerp > next.time)\n    {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n    const curVal = current.value;\n    const nextVal = next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n\n    return combineRGBComponents(r, g, b);\n}\n\nfunction intValueStepped(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n\n    while (current.next && lerp > current.next.time)\n    {\n        current = current.next;\n    }\n\n    return current.value;\n}\n\nfunction intColorStepped(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n\n    while (current.next && lerp > current.next.time)\n    {\n        current = current.next;\n    }\n    const curVal = current.value;\n\n    return combineRGBComponents(curVal.r, curVal.g, curVal.b);\n}\n\n/**\n * Singly linked list container for keeping track of interpolated properties for particles.\n * Each Particle will have one of these for each interpolated property.\n */\nexport class PropertyList<V>\n{\n    /**\n     * The first property node in the linked list.\n     */\n    public first: PropertyNode<V>;\n    /**\n     * Calculates the correct value for the current interpolation value. This method is set in\n     * the reset() method.\n     * @param lerp The interpolation value from 0-1.\n     * @return The interpolated value. Colors are converted to the hex value.\n     */\n    public interpolate: (lerp: number) => number;\n    /**\n     * A custom easing method for this list.\n     * @param lerp The interpolation value from 0-1.\n     * @return The eased value, also from 0-1.\n     */\n    public ease: SimpleEase;\n    /**\n     * If this list manages colors, which requires a different method for interpolation.\n     */\n    private isColor: boolean;\n\n    /**\n     * @param isColor If this list handles color values\n     */\n    constructor(isColor = false)\n    {\n        this.first = null;\n        this.isColor = !!isColor;\n        this.interpolate = null;\n        this.ease = null;\n    }\n\n    /**\n     * Resets the list for use.\n     * @param first The first node in the list.\n     * @param first.isStepped If the values should be stepped instead of interpolated linearly.\n     */\n    public reset(first: PropertyNode<V>): void\n    {\n        this.first = first;\n        const isSimple = first.next && first.next.time >= 1;\n\n        if (isSimple)\n        {\n            this.interpolate = this.isColor ? intColorSimple : intValueSimple;\n        }\n        else if (first.isStepped)\n        {\n            this.interpolate = this.isColor ? intColorStepped : intValueStepped;\n        }\n        else\n        {\n            this.interpolate = this.isColor ? intColorComplex : intValueComplex;\n        }\n        this.ease = this.first.ease;\n    }\n}\n","import { Particle } from '../Particle';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * An Alpha behavior that applies an interpolated or stepped list of values to the particle's opacity.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'alpha',\n *     config: {\n *         alpha: {\n *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}]\n *         },\n *     }\n * }\n * ```\n */\nexport class AlphaBehavior implements IEmitterBehavior\n{\n    public static type = 'alpha';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<number>;\n    constructor(config: {\n        /**\n         * Transparency of the particles from 0 (transparent) to 1 (opaque)\n         */\n        alpha: ValueList<number>;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.alpha));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.alpha = this.list.first.value;\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.alpha = this.list.interpolate(particle.agePercent);\n    }\n}\n\n/**\n * An Alpha behavior that applies a static value to the particle's opacity at particle initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'alphaStatic',\n *     config: {\n *         alpha: 0.75,\n *     }\n * }\n * ```\n */\nexport class StaticAlphaBehavior implements IEmitterBehavior\n{\n    public static type = 'alphaStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: number;\n    constructor(config: {\n        /**\n         * Transparency of the particles from 0 (transparent) to 1 (opaque)\n         */\n        alpha: number;\n    })\n    {\n        this.value = config.alpha;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.alpha = this.value;\n            next = next.next;\n        }\n    }\n}\n","import { Texture } from 'pixi.js';\nimport { Particle } from '../Particle';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * The format of a single animation to be used on a particle.\n */\nexport interface AnimatedParticleArt\n{\n    /**\n     * Framerate for the animation (in frames per second). A value of -1 will tie the framerate to\n     * the particle's lifetime so that the animation lasts exactly as long as the particle.\n     */\n    framerate: -1 | number;\n    /**\n     * If the animation should loop. Defaults to false.\n     */\n    loop?: boolean;\n    /**\n     * A list of textures or frame descriptions for duplicated frames.\n     * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n     * Example of a texture repeated for 5 frames, followed by a second texture for one frame:\n     * ```javascript\n     * [{texture: 'myFirstTex', count: 5}, 'mySecondTex']\n     * ```\n     */\n    textures: (string | Texture | {texture: string | Texture; count: number})[];\n}\n\n/**\n * Internal data format for playback.\n */\nexport interface ParsedAnimatedParticleArt\n{\n    textures: Texture[];\n    duration: number;\n    framerate: number;\n    loop: boolean;\n}\n\nfunction getTextures(textures: (string | Texture | {texture: string | Texture; count: number})[]): Texture[]\n{\n    const outTextures: Texture[] = [];\n\n    for (let j = 0; j < textures.length; ++j)\n    {\n        let tex = textures[j];\n\n        if (typeof tex === 'string')\n        {\n            outTextures.push(GetTextureFromString(tex));\n        }\n        else if (tex instanceof Texture)\n        {\n            outTextures.push(tex);\n        }\n        // assume an object with extra data determining duplicate frame data\n        else\n        {\n            let dupe = tex.count || 1;\n\n            if (typeof tex.texture === 'string')\n            {\n                tex = GetTextureFromString(tex.texture);\n            }\n            else// if(tex.texture instanceof Texture)\n            {\n                tex = tex.texture;\n            }\n            for (; dupe > 0; --dupe)\n            {\n                outTextures.push(tex);\n            }\n        }\n    }\n\n    return outTextures;\n}\n\n/**\n * A Texture behavior that picks a random animation for each particle to play.\n * See {@link AnimatedParticleArt} for detailed configuration info.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'animatedRandom',\n *     config: {\n *         anims: [\n *              {\n *                  framerate: 25,\n *                  loop: true,\n *                  textures: ['frame1', 'frame2', 'frame3']\n *              },\n *              {\n *                  framerate: 25,\n *                  loop: true,\n *                  textures: ['frame3', 'frame2', 'frame1']\n *              }\n *         ],\n *     }\n * }\n * ```\n */\nexport class RandomAnimatedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'animatedRandom';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private anims: ParsedAnimatedParticleArt[];\n    constructor(config: {\n        /**\n         * Animation configuration to use for each particle, randomly chosen from the list.\n         */\n        anims: AnimatedParticleArt[];\n    })\n    {\n        this.anims = [];\n        for (let i = 0; i < config.anims.length; ++i)\n        {\n            const anim = config.anims[i];\n            const textures = getTextures(anim.textures);\n            // eslint-disable-next-line no-nested-ternary\n            const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n            const parsedAnim: ParsedAnimatedParticleArt = {\n                textures,\n                duration: framerate > 0 ? textures.length / framerate : 0,\n                framerate,\n                loop: framerate > 0 ? !!anim.loop : false,\n            };\n\n            this.anims.push(parsedAnim);\n        }\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const index = Math.floor(Math.random() * this.anims.length);\n            const anim = next.config.anim = this.anims[index];\n\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1)\n            {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else\n            {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const config = particle.config;\n        const anim = config.anim;\n\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration)\n        {\n            // loop elapsed back around\n            if (config.anim.loop)\n            {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else\n            {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\n\n/**\n * A Texture behavior that uses a single animation for each particle to play.\n * See {@link AnimatedParticleArt} for detailed configuration info.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'animatedSingle',\n *     config: {\n *         anim: {\n *              framerate: 25,\n *              loop: true,\n *              textures: ['frame1', 'frame2', 'frame3']\n *         }\n *     }\n * }\n * ```\n */\nexport class SingleAnimatedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'animatedSingle';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private anim: ParsedAnimatedParticleArt;\n    constructor(config: {\n        /**\n         * Animation configuration to use for each particle.\n         */\n        anim: AnimatedParticleArt;\n    })\n    {\n        const anim = config.anim;\n        const textures = getTextures(anim.textures);\n        // eslint-disable-next-line no-nested-ternary\n        const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n\n        this.anim = {\n            textures,\n            duration: framerate > 0 ? textures.length / framerate : 0,\n            framerate,\n            loop: framerate > 0 ? !!anim.loop : false,\n        };\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n        const anim = this.anim;\n\n        while (next)\n        {\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1)\n            {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else\n            {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const anim = this.anim;\n        const config = particle.config;\n\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration)\n        {\n            // loop elapsed back around\n            if (anim.loop)\n            {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else\n            {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\n","import { BLEND_MODES } from 'pixi.js';\nimport { Particle } from '../Particle';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Blend Mode behavior that applies a blend mode value to the particle at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'blendMode',\n *     config: {\n *         blendMode: 'multiply',\n *     }\n * }\n * ```\n */\nexport class BlendModeBehavior implements IEmitterBehavior\n{\n    public static type = 'blendMode';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: BLEND_MODES;\n    constructor(config: {\n        /**\n         * Blend mode of all particles. This value is a key from\n         * [PixiJs's BLEND_MODE enum](https://pixijs.download/release/docs/PIXI.html#BLEND_MODES).\n         */\n        blendMode: BLEND_MODES;\n    })\n    {\n        this.value = config.blendMode;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.blendMode = this.value;\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { DEG_TO_RADS, rotatePoint } from '../ParticleUtils';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Spawn behavior that sends particles out from a single point or ring, and is capable of evenly spacing\n * the particle's starting angles.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnBurst',\n *     config: {\n *          spacing: 90,\n *          start: 0,\n *          distance: 40,\n *     }\n * }\n * ```\n */\nexport class BurstSpawnBehavior implements IEmitterBehavior\n{\n    public static type = 'spawnBurst';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    order = BehaviorOrder.Spawn;\n    private spacing: number;\n    private start: number;\n    private distance: number;\n\n    constructor(config: {\n        /**\n         * Description: Spacing between each particle spawned in a wave, in degrees.\n         */\n        spacing: number;\n        /**\n         * Description: Angle to start placing particles at, in degrees. 0 is facing right, 90 is facing upwards.\n         */\n        start: number;\n        /**\n         * Description: Distance from the emitter to spawn particles, forming a ring/arc.\n         */\n        distance: number;\n    })\n    {\n        this.spacing = config.spacing * DEG_TO_RADS;\n        this.start = config.start * DEG_TO_RADS;\n        this.distance = config.distance;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let count = 0;\n        let next = first;\n\n        while (next)\n        {\n            let angle: number;\n\n            if (this.spacing)\n            {\n                angle = this.start + (this.spacing * count);\n            }\n            else\n            {\n                angle = Math.random() * Math.PI * 2;\n            }\n\n            next.rotation = angle;\n            if (this.distance)\n            {\n                next.position.x = this.distance;\n                rotatePoint(angle, next.position);\n            }\n            next = next.next;\n            ++count;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { Color, combineRGBComponents } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Color behavior that applies an interpolated or stepped list of values to the particle's tint property.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'color',\n *     config: {\n *         color: {\n *              list: [{value: '#ff0000' time: 0}, {value: '#00ff00', time: 0.5}, {value: '#0000ff', time: 1}]\n *         },\n *     }\n * }\n * ```\n */\nexport class ColorBehavior implements IEmitterBehavior\n{\n    public static type = 'color';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<Color>;\n    constructor(config: {\n        /**\n         * Color of the particles as 6 digit hex codes.\n         */\n        color: ValueList<string>;\n    })\n    {\n        this.list = new PropertyList(true);\n        this.list.reset(PropertyNode.createList(config.color));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n        const color = this.list.first.value;\n        const tint = combineRGBComponents(color.r, color.g, color.b);\n\n        while (next)\n        {\n            next.tint = tint;\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.tint = this.list.interpolate(particle.agePercent);\n    }\n}\n\n/**\n * A Color behavior that applies a single color to the particle's tint property at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'colorStatic',\n *     config: {\n *         color: '#ffff00',\n *     }\n * }\n * ```\n */\nexport class StaticColorBehavior implements IEmitterBehavior\n{\n    public static type = 'colorStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: number;\n    constructor(config: {\n        /**\n         * Color of the particles as 6 digit hex codes.\n         */\n        color: string;\n    })\n    {\n        let color = config.color;\n\n        if (color.charAt(0) === '#')\n        {\n            color = color.substr(1);\n        }\n        else if (color.indexOf('0x') === 0)\n        {\n            color = color.substr(2);\n        }\n\n        this.value = parseInt(color, 16);\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.tint = this.value;\n            next = next.next;\n        }\n    }\n}\n","import { Texture } from 'pixi.js';\nimport { Particle } from '../Particle';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Texture behavior that assigns a texture to each particle from its list, in order, before looping around to the first\n * texture again. String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureOrdered',\n *     config: {\n *         textures: [\"myTex1Id\", \"myTex2Id\", \"myTex3Id\", \"myTex4Id\"],\n *     }\n * }\n * ```\n */\nexport class OrderedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureOrdered';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private textures: Texture[];\n    private index: number;\n    constructor(config: {\n        /**\n         * Images to use for each particle, used in order before looping around\n         */\n        textures: Texture[];\n    })\n    {\n        this.index = 0;\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.texture = this.textures[this.index];\n            if (++this.index >= this.textures.length)\n            {\n                this.index = 0;\n            }\n            next = next.next;\n        }\n    }\n}\n","import { Point } from 'pixi.js';\nimport { Particle } from '../Particle';\nimport { rotatePoint, verbose } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A helper point for math things.\n * @hidden\n */\nconst helperPoint = new Point();\n\n/**\n * A hand picked list of Math functions (and a couple properties) that are\n * allowable. They should be used without the preceding \"Math.\"\n * @hidden\n */\nconst MATH_FUNCS = [\n    'E',\n    'LN2',\n    'LN10',\n    'LOG2E',\n    'LOG10E',\n    'PI',\n    'SQRT1_2',\n    'SQRT2',\n    'abs',\n    'acos',\n    'acosh',\n    'asin',\n    'asinh',\n    'atan',\n    'atanh',\n    'atan2',\n    'cbrt',\n    'ceil',\n    'cos',\n    'cosh',\n    'exp',\n    'expm1',\n    'floor',\n    'fround',\n    'hypot',\n    'log',\n    'log1p',\n    'log10',\n    'log2',\n    'max',\n    'min',\n    'pow',\n    'random',\n    'round',\n    'sign',\n    'sin',\n    'sinh',\n    'sqrt',\n    'tan',\n    'tanh',\n];\n/**\n * create an actual regular expression object from the string\n * @hidden\n */\nconst WHITELISTER = new RegExp(\n    [\n        // Allow the 4 basic operations, parentheses and all numbers/decimals, as well\n        // as 'x', for the variable usage.\n        '[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]',\n    ].concat(MATH_FUNCS).join('|'),\n    'g',\n);\n\n/**\n * Parses a string into a function for path following.\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\n * names, and using `new Function()` to generate a function.\n * @hidden\n * @param pathString The string to parse.\n * @return The path function - takes x, outputs y.\n */\nfunction parsePath(pathString: string): (x: number) => number\n{\n    const matches = pathString.match(WHITELISTER);\n\n    for (let i = matches.length - 1; i >= 0; --i)\n    {\n        if (MATH_FUNCS.indexOf(matches[i]) >= 0)\n        { matches[i] = `Math.${matches[i]}`; }\n    }\n    pathString = matches.join('');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('x', `return ${pathString};`) as (x: number) => number;\n}\n\n/**\n * A particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\n * \"5x + 3\".\n * To use this class, the behavior config must have a \"path\" string or function.\n *\n * A string should have \"x\" in it to represent movement (from the\n * speed settings of the behavior). It may have numbers, parentheses, the four basic\n * operations, and any Math functions or properties (without the preceding \"Math.\").\n * The overall movement of the particle and the expression value become x and y positions for\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\n * the particle.\n *\n * A function merely needs to accept the \"x\" argument and output the a corresponding \"y\" value.\n *\n * Some example paths:\n *\n * * `\"sin(x/10) * 20\"` A sine wave path.\n * * `\"cos(x/100) * 30\"` Particles curve counterclockwise (for medium speed/low lifetime particles)\n * * `\"pow(x/10, 2) / 2\"` Particles curve clockwise (remember, +y is down).\n * * `(x) => Math.floor(x) * 3` Supplying an existing function should look like this\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"movePath\",\n *     \"config\": {\n *          \"path\": \"round(sin(x) * 2\",\n *          \"speed\": {\n *              \"list\": [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],\n *          },\n *          \"minMult\": 0.8\n *     }\n *}\n */\nexport class PathBehavior implements IEmitterBehavior\n{\n    public static type = 'movePath';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    // *MUST* happen after other behaviors do initialization so that we can read initial transformations\n    public order = BehaviorOrder.Late;\n    /**\n     * The function representing the path the particle should take.\n     */\n    private path: (x: number) => number;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Algebraic expression describing the movement of the particle.\n         */\n        path: string | ((x: number) => number);\n        /**\n         * Speed of the particles in world units/second. This affects the x value in the path.\n         * Unlike normal speed movement, this can have negative values.\n         */\n        speed: ValueList<number>;\n        /**\n         * A value between minimum speed multipler and 1 is randomly generated and multiplied\n         * with each speed value to generate the actual speed for each particle.\n         */\n        minMult: number;\n    })\n    {\n        if (config.path)\n        {\n            if (typeof config.path === 'function')\n            {\n                this.path = config.path;\n            }\n            else\n            {\n                try\n                {\n                    this.path = parsePath(config.path);\n                }\n                catch (e)\n                {\n                    if (verbose)\n                    {\n                        console.error('PathParticle: error in parsing path expression', e);\n                    }\n                    this.path = null;\n                }\n            }\n        }\n        else\n        {\n            if (verbose)\n            {\n                console.error('PathParticle requires a path value in its config!');\n            }\n            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n            this.path = (x) => x;\n        }\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            /*\n             * The initial rotation in degrees of the particle, because the direction of the path\n             * is based on that.\n             */\n            next.config.initRotation = next.rotation;\n            /* The initial position of the particle, as all path movement is added to that. */\n            if (!next.config.initPosition)\n            {\n                next.config.initPosition = new Point(next.x, next.y);\n            }\n            else\n            {\n                (next.config.initPosition as Point).copyFrom(next.position);\n            }\n            /* Total single directional movement, due to speed. */\n            next.config.movement = 0;\n\n            // also do speed multiplier, since this includes basic speed movement\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.speedMult = mult;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        // increase linear movement based on speed\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n\n        particle.config.movement += speed * deltaSec;\n        // set up the helper point for rotation\n        helperPoint.x = particle.config.movement;\n        helperPoint.y = this.path(helperPoint.x);\n        rotatePoint(particle.config.initRotation, helperPoint);\n        particle.position.x = particle.config.initPosition.x + helperPoint.x;\n        particle.position.y = particle.config.initPosition.y + helperPoint.y;\n    }\n}\n","import { Particle } from '../Particle';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Spawn behavior that sends particles out from a single point at the emitter's position.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnPoint',\n *     config: {}\n * }\n * ```\n */\nexport class PointSpawnBehavior implements IEmitterBehavior\n{\n    public static type = 'spawnPoint';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    order = BehaviorOrder.Spawn;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    initParticles(_first: Particle): void\n    {\n        // really just a no-op\n    }\n}\n","import { Texture } from 'pixi.js';\nimport { Particle } from '../Particle';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Texture behavior that assigns a random texture to each particle from its list.\n * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureRandom',\n *     config: {\n *         textures: [\"myTex1Id\", \"myTex2Id\", \"myTex3Id\", \"myTex4Id\"],\n *     }\n * }\n * ```\n */\nexport class RandomTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureRandom';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private textures: Texture[];\n    constructor(config: {\n        /**\n         * Images to use for each particle, randomly chosen from the list.\n         */\n        textures: (Texture | string)[];\n    })\n    {\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const index = Math.floor(Math.random() * this.textures.length);\n\n            next.texture = this.textures[index];\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { DEG_TO_RADS } from '../ParticleUtils';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Rotation behavior that handles starting rotation, rotation speed, and rotational acceleration.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"rotation\",\n *     \"config\": {\n *          \"minStart\": 0,\n *          \"maxStart\": 180,\n *          \"minSpeed\": 30,\n *          \"maxSpeed\": 45,\n *          \"accel\": 20\n *     }\n *}\n * ```\n */\nexport class RotationBehavior implements IEmitterBehavior\n{\n    public static type = 'rotation';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private minStart: number;\n    private maxStart: number;\n    private minSpeed: number;\n    private maxSpeed: number;\n    private accel: number;\n    constructor(config: {\n        /**\n         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        minStart: number;\n        /**\n         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        maxStart: number;\n        /**\n         * Minimum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.\n         */\n        minSpeed: number;\n        /**\n         * Maximum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.\n         */\n        maxSpeed: number;\n        /**\n         * Constant rotational acceleration of the particles, in degrees/second/second.\n         */\n        accel: number;\n    })\n    {\n        this.minStart = config.minStart * DEG_TO_RADS;\n        this.maxStart = config.maxStart * DEG_TO_RADS;\n        this.minSpeed = config.minSpeed * DEG_TO_RADS;\n        this.maxSpeed = config.maxSpeed * DEG_TO_RADS;\n        this.accel = config.accel * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            if (this.minStart === this.maxStart)\n            {\n                next.rotation += this.maxStart;\n            }\n            else\n            {\n                next.rotation += (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n            }\n            next.config.rotSpeed = (Math.random() * (this.maxSpeed - this.minSpeed)) + this.minSpeed;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        if (this.accel)\n        {\n            const oldSpeed = particle.config.rotSpeed;\n\n            particle.config.rotSpeed += this.accel * deltaSec;\n            particle.rotation += (particle.config.rotSpeed + oldSpeed) / 2 * deltaSec;\n        }\n        else\n        {\n            particle.rotation += particle.config.rotSpeed * deltaSec;\n        }\n    }\n}\n\n/**\n * A Rotation behavior that handles starting rotation.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"rotationStatic\",\n *     \"config\": {\n *          \"min\": 0,\n *          \"max\": 180,\n *     }\n *}\n * ```\n */\nexport class StaticRotationBehavior implements IEmitterBehavior\n{\n    public static type = 'rotationStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        min: number;\n        /**\n         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        max: number;\n    })\n    {\n        this.min = config.min * DEG_TO_RADS;\n        this.max = config.max * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            if (this.min === this.max)\n            {\n                next.rotation += this.max;\n            }\n            else\n            {\n                next.rotation += (Math.random() * (this.max - this.min)) + this.min;\n            }\n\n            next = next.next;\n        }\n    }\n}\n\n/**\n * A Rotation behavior that blocks all rotation caused by spawn settings,\n * by resetting it to the specified rotation (or 0).\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"noRotation\",\n *     \"config\": {\n *          \"rotation\": 0\n *     }\n *}\n * ```\n */\nexport class NoRotationBehavior implements IEmitterBehavior\n{\n    public static type = 'noRotation';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late + 1;\n\n    private rotation: number;\n    constructor(config: {\n        /**\n         * Locked rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        rotation?: number;\n    })\n    {\n        this.rotation = (config.rotation || 0) * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.rotation = this.rotation;\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Scale behavior that applies an interpolated or stepped list of values to the particle's x & y scale.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'scale',\n *     config: {\n *          scale: {\n *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}],\n *              isStepped: true\n *          },\n *          minMult: 0.5\n *     }\n * }\n * ```\n */\nexport class ScaleBehavior implements IEmitterBehavior\n{\n    public static type = 'scale';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Scale of the particles, with a minimum value of 0\n         */\n        scale: ValueList<number>;\n        /**\n         * A value between minimum scale multipler and 1 is randomly\n         * generated and multiplied with each scale value to provide the actual scale for each particle.\n         */\n        minMult: number;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.scale));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.scaleMult = mult;\n            next.scale.x = next.scale.y = this.list.first.value * mult;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.scale.x = particle.scale.y = this.list.interpolate(particle.agePercent) * particle.config.scaleMult;\n    }\n}\n\n/**\n * A Scale behavior that applies a randomly picked value to the particle's x & y scale at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'scaleStatic',\n *     config: {\n *         min: 0.25,\n *         max: 0.75,\n *     }\n * }\n * ```\n */\nexport class StaticScaleBehavior implements IEmitterBehavior\n{\n    public static type = 'scaleStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum scale of the particles, with a minimum value of 0\n         */\n        min: number;\n        /**\n         * Maximum scale of the particles, with a minimum value of 0\n         */\n        max: number;\n    })\n    {\n        this.min = config.min;\n        this.max = config.max;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const scale = (Math.random() * (this.max - this.min)) + this.min;\n\n            next.scale.x = next.scale.y = scale;\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\nimport { PolygonalChain } from './shapes/PolygonalChain';\nimport { Rectangle } from './shapes/Rectangle';\nimport { SpawnShape, SpawnShapeClass } from './shapes/SpawnShape';\nimport { Torus } from './shapes/Torus';\n\n/**\n * A Spawn behavior that places (and optionally rotates) particles according to a\n * specified shape. Additional shapes can be registered with {@link registerShape | SpawnShape.registerShape()}.\n * Additional shapes must implement the {@link SpawnShape} interface, and their class must match the\n * {@link SpawnShapeClass} interface.\n * Shapes included by default are:\n * * {@link Rectangle}\n * * {@link Torus}\n * * {@link PolygonalChain}\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnShape',\n *     config: {\n *          type: 'rect',\n *          data: {\n *              x: 0,\n *              y: 0,\n *              width: 20,\n *              height: 300,\n *          }\n *     }\n * }\n * ```\n */\nexport class ShapeSpawnBehavior implements IEmitterBehavior\n{\n    public static type = 'spawnShape';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    /**\n     * Dictionary of all registered shape classes.\n     */\n    private static shapes: {[key: string]: SpawnShapeClass} = {};\n\n    /**\n     * Registers a shape to be used by the ShapeSpawn behavior.\n     * @param constructor The shape class constructor to use, with a static `type` property to reference it by.\n     * @param typeOverride An optional type override, primarily for registering a shape under multiple names.\n     */\n    public static registerShape(constructor: SpawnShapeClass, typeOverride?: string): void\n    {\n        ShapeSpawnBehavior.shapes[typeOverride || constructor.type] = constructor;\n    }\n\n    order = BehaviorOrder.Spawn;\n    private shape: SpawnShape;\n\n    constructor(config: {\n        /**\n         * Type of the shape to spawn\n         */\n        type: string;\n        /**\n         * Configuration data for the spawn shape.\n         */\n        data: any;\n    })\n    {\n        const ShapeClass = ShapeSpawnBehavior.shapes[config.type];\n\n        if (!ShapeClass)\n        {\n            throw new Error(`No shape found with type '${config.type}'`);\n        }\n        this.shape = new ShapeClass(config.data);\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            this.shape.getRandPos(next);\n            next = next.next;\n        }\n    }\n}\n\nShapeSpawnBehavior.registerShape(PolygonalChain);\nShapeSpawnBehavior.registerShape(Rectangle);\nShapeSpawnBehavior.registerShape(Torus);\nShapeSpawnBehavior.registerShape(Torus, 'circle');\n","import { Texture } from 'pixi.js';\nimport { Particle } from '../Particle';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Textuure behavior that assigns a single texture to each particle.\n * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureSingle',\n *     config: {\n *         texture: Texture.from('myTexId'),\n *     }\n * }\n * ```\n */\nexport class SingleTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureSingle';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private texture: Texture;\n    constructor(config: {\n        /**\n         * Image to use for each particle.\n         */\n        texture: Texture | string;\n    })\n    {\n        this.texture = typeof config.texture === 'string' ? GetTextureFromString(config.texture) : config.texture;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.texture = this.texture;\n\n            next = next.next;\n        }\n    }\n}\n","import { Point } from 'pixi.js';\nimport { Particle } from '../Particle';\nimport { normalize, rotatePoint, scaleBy } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { BehaviorOrder, IEmitterBehavior } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Movement behavior that uses an interpolated or stepped list of values for a particles speed at any given moment.\n * Movement direction is controlled by the particle's starting rotation.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'moveSpeed',\n *     config: {\n *          speed: {\n *              list: [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],\n *          },\n *          minMult: 0.8\n *     }\n * }\n * ```\n */\nexport class SpeedBehavior implements IEmitterBehavior\n{\n    public static type = 'moveSpeed';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Speed of the particles in world units/second, with a minimum value of 0\n         */\n        speed: ValueList<number>;\n        /**\n         * A value between minimum speed multipler and 1 is randomly\n         * generated and multiplied with each speed value to generate the actual speed for each particle.\n         */\n        minMult: number;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.speedMult = mult;\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(this.list.first.value * mult, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(this.list.first.value * mult, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n        const vel = particle.config.velocity;\n\n        normalize(vel);\n        scaleBy(vel, speed);\n        particle.x += vel.x * deltaSec;\n        particle.y += vel.y * deltaSec;\n    }\n}\n\n/**\n * A Movement behavior that uses a randomly picked constant speed throughout a particle's lifetime.\n * Movement direction is controlled by the particle's starting rotation.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'moveSpeedStatic',\n *     config: {\n *          min: 100,\n *          max: 150\n *     }\n * }\n * ```\n */\nexport class StaticSpeedBehavior implements IEmitterBehavior\n{\n    public static type = 'moveSpeedStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum speed when initializing the particle.\n         */\n        min: number;\n        /**\n         * Maximum speed when initializing the particle.\n         */\n        max: number;\n    })\n    {\n        this.min = config.min;\n        this.max = config.max;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const speed = (Math.random() * (this.max - this.min)) + this.min;\n\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(speed, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const velocity = particle.config.velocity;\n\n        particle.x += velocity.x * deltaSec;\n        particle.y += velocity.y * deltaSec;\n    }\n}\n","import { Sprite } from 'pixi.js';\nimport { Emitter } from './Emitter';\nimport { LinkedListChild } from './LinkedListChild';\n\n/**\n * An individual particle image. You shouldn't have to deal with these.\n */\nexport class Particle extends Sprite implements LinkedListChild\n{\n    /**\n     * The emitter that controls this particle.\n     */\n    public emitter: Emitter;\n    /**\n     * The maximum lifetime of this particle, in seconds.\n     */\n    public maxLife: number;\n    /**\n     * The current age of the particle, in seconds.\n     */\n    public age: number;\n    /**\n     * The current age of the particle as a normalized value between 0 and 1.\n     */\n    public agePercent: number;\n    /**\n     * One divided by the max life of the particle, saved for slightly faster math.\n     */\n    public oneOverLife: number;\n    /**\n     * Reference to the next particle in the list.\n     */\n    public next: Particle;\n\n    /**\n     * Reference to the previous particle in the list.\n     */\n    public prev: Particle;\n\n    public prevChild: LinkedListChild;\n    public nextChild: LinkedListChild;\n\n    /**\n     * Static per-particle configuration for behaviors to use. Is not cleared when recycling.\n     */\n    public config: {[key: string]: any};\n\n    /**\n     * @param emitter The emitter that controls this particle.\n     */\n    constructor(emitter: Emitter)\n    {\n        // start off the sprite with a blank texture, since we are going to replace it\n        // later when the particle is initialized.\n        super();\n        // initialize LinkedListChild props so they are included in underlying JS class definition\n        this.prevChild = this.nextChild = null;\n\n        this.emitter = emitter;\n        this.config = {};\n        // particles should be centered\n        this.anchor.x = this.anchor.y = 0.5;\n        this.maxLife = 0;\n        this.age = 0;\n        this.agePercent = 0;\n        this.oneOverLife = 0;\n        this.next = null;\n        this.prev = null;\n\n        // save often used functions on the instance instead of the prototype for better speed\n        this.init = this.init;\n        this.kill = this.kill;\n    }\n\n    /**\n     * Initializes the particle for use, based on the properties that have to\n     * have been set already on the particle.\n     */\n    public init(maxLife: number): void\n    {\n        this.maxLife = maxLife;\n        // reset the age\n        this.age = this.agePercent = 0;\n        // reset the sprite props\n        this.rotation = 0;\n        this.position.x = this.position.y = 0;\n        this.scale.x = this.scale.y = 1;\n        this.tint = 0xffffff;\n        this.alpha = 1;\n        // save our lerp helper\n        this.oneOverLife = 1 / this.maxLife;\n\n        // ensure visibility\n        this.visible = true;\n    }\n\n    /**\n     * Kills the particle, removing it from the display list\n     * and telling the emitter to recycle it.\n     */\n    public kill(): void\n    {\n        this.emitter.recycle(this);\n    }\n\n    /**\n     * Destroys the particle, removing references and preventing future use.\n     */\n    public destroy(): void\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this.emitter = this.next = this.prev = null;\n        super.destroy();\n    }\n}\n","import { Container, Point, Ticker } from 'pixi.js';\nimport { BehaviorOrder, IEmitterBehavior, IEmitterBehaviorClass } from './behaviors/Behaviors';\nimport { EmitterConfigV3 } from './EmitterConfig';\nimport { Particle } from './Particle';\nimport { generateEase, rotatePoint, SimpleEase } from './ParticleUtils';\n// get the shared ticker, only supports V5 and V6 with individual packages\n/**\n * @hidden\n */\nconst ticker = Ticker.shared;\n\n/**\n * Key used in sorted order to determine when to set particle position from the emitter position\n * and rotation.\n */\nconst PositionParticle = Symbol('Position particle per emitter position');\n\n/**\n * A particle emitter.\n */\nexport class Emitter\n{\n    private static knownBehaviors: {[key: string]: IEmitterBehaviorClass} = {};\n\n    /**\n     * Registers a new behavior, so that it will be recognized when initializing emitters.\n     * Behaviors registered later with duplicate types will override older ones, although there is no limit on\n     * the allowed types.\n     * @param constructor The behavior class to register.\n     */\n    public static registerBehavior(constructor: IEmitterBehaviorClass): void\n    {\n        Emitter.knownBehaviors[constructor.type] = constructor;\n    }\n\n    /**\n     * Active initialization behaviors for this emitter.\n     */\n    protected initBehaviors: (IEmitterBehavior | typeof PositionParticle)[];\n    /**\n     * Active update behaviors for this emitter.\n     */\n    protected updateBehaviors: IEmitterBehavior[];\n    /**\n     * Active recycle behaviors for this emitter.\n     */\n    protected recycleBehaviors: IEmitterBehavior[];\n    // properties for individual particles\n    /**\n     * The minimum lifetime for a particle, in seconds.\n     */\n    public minLifetime: number;\n    /**\n     * The maximum lifetime for a particle, in seconds.\n     */\n    public maxLifetime: number;\n    /**\n     * An easing function for nonlinear interpolation of values. Accepts a single\n     * parameter of time as a value from 0-1, inclusive. Expected outputs are values\n     * from 0-1, inclusive.\n     */\n    public customEase: SimpleEase;\n    // properties for spawning particles\n    /**\n     * Time between particle spawns in seconds.\n     */\n    protected _frequency: number;\n    /**\n     * Chance that a particle will be spawned on each opportunity to spawn one.\n     * 0 is 0%, 1 is 100%.\n     */\n    public spawnChance: number;\n    /**\n     * Maximum number of particles to keep alive at a time. If this limit\n     * is reached, no more particles will spawn until some have died.\n     */\n    public maxParticles: number;\n    /**\n     * The amount of time in seconds to emit for before setting emit to false.\n     * A value of -1 is an unlimited amount of time.\n     */\n    public emitterLifetime: number;\n    /**\n     * Position at which to spawn particles, relative to the emitter's owner's origin.\n     * For example, the flames of a rocket travelling right might have a spawnPos\n     * of {x:-50, y:0}.\n     * to spawn at the rear of the rocket.\n     * To change this, use updateSpawnPos().\n     */\n    public spawnPos: Point;\n    /**\n     * Number of particles to spawn time that the frequency allows for particles to spawn.\n     */\n    public particlesPerWave: number;\n    /**\n     * Rotation of the emitter or emitter's owner in degrees. This is added to\n     * the calculated spawn angle.\n     * To change this, use rotate().\n     */\n    protected rotation: number;\n    /**\n     * The world position of the emitter's owner, to add spawnPos to when\n     * spawning particles. To change this, use updateOwnerPos().\n     */\n    protected ownerPos: Point;\n    /**\n     * The origin + spawnPos in the previous update, so that the spawn position\n     * can be interpolated to space out particles better.\n     */\n    protected _prevEmitterPos: Point;\n    /**\n     * If _prevEmitterPos is valid, to prevent interpolation on the first update\n     */\n    protected _prevPosIsValid: boolean;\n    /**\n     * If either ownerPos or spawnPos has changed since the previous update.\n     */\n    protected _posChanged: boolean;\n    /**\n     * The container to add particles to.\n     */\n    protected _parent: Container;\n    /**\n     * If particles should be added at the back of the display list instead of the front.\n     */\n    public addAtBack: boolean;\n    /**\n     * The current number of active particles.\n     */\n    public particleCount: number;\n    /**\n     * If particles should be emitted during update() calls. Setting this to false\n     * stops new particles from being created, but allows existing ones to die out.\n     */\n    protected _emit: boolean;\n    /**\n     * The timer for when to spawn particles in seconds, where numbers less\n     * than 0 mean that particles should be spawned.\n     */\n    protected _spawnTimer: number;\n    /**\n     * The life of the emitter in seconds.\n     */\n    protected _emitterLife: number;\n    /**\n     * The particles that are active and on the display list. This is the first particle in a\n     * linked list.\n     */\n    protected _activeParticlesFirst: Particle;\n    /**\n     * The particles that are active and on the display list. This is the last particle in a\n     * linked list.\n     */\n    protected _activeParticlesLast: Particle;\n    /**\n     * The particles that are not currently being used. This is the first particle in a\n     * linked list.\n     */\n    protected _poolFirst: Particle;\n    /**\n     * The original config object that this emitter was initialized with.\n     */\n    protected _origConfig: any;\n    /**\n     * If the update function is called automatically from the shared ticker.\n     * Setting this to false requires calling the update function manually.\n     */\n    protected _autoUpdate: boolean;\n    /**\n     * If the emitter should destroy itself when all particles have died out. This is set by\n     * playOnceAndDestroy();\n     */\n    protected _destroyWhenComplete: boolean;\n    /**\n     * A callback for when all particles have died out. This is set by\n     * playOnceAndDestroy() or playOnce();\n     */\n    protected _completeCallback: () => void;\n\n    /**\n     * @param particleParent The container to add the particles to.\n     * @param particleImages A texture or array of textures to use\n     *                       for the particles. Strings will be turned\n     *                       into textures via Texture.from().\n     * @param config A configuration object containing settings for the emitter.\n     * @param config.emit If config.emit is explicitly passed as false, the\n     *                    Emitter will start disabled.\n     * @param config.autoUpdate If config.autoUpdate is explicitly passed as\n     *                          true, the Emitter will automatically call\n     *                          update via the PIXI shared ticker.\n     */\n    constructor(particleParent: Container, config: EmitterConfigV3)\n    {\n        this.initBehaviors = [];\n        this.updateBehaviors = [];\n        this.recycleBehaviors = [];\n        // properties for individual particles\n        this.minLifetime = 0;\n        this.maxLifetime = 0;\n        this.customEase = null;\n        // properties for spawning particles\n        this._frequency = 1;\n        this.spawnChance = 1;\n        this.maxParticles = 1000;\n        this.emitterLifetime = -1;\n        this.spawnPos = new Point();\n        this.particlesPerWave = 1;\n        // emitter properties\n        this.rotation = 0;\n        this.ownerPos = new Point();\n        this._prevEmitterPos = new Point();\n        this._prevPosIsValid = false;\n        this._posChanged = false;\n        this._parent = null;\n        this.addAtBack = false;\n        this.particleCount = 0;\n        this._emit = false;\n        this._spawnTimer = 0;\n        this._emitterLife = -1;\n        this._activeParticlesFirst = null;\n        this._activeParticlesLast = null;\n        this._poolFirst = null;\n        this._origConfig = null;\n        this._autoUpdate = false;\n        this._destroyWhenComplete = false;\n        this._completeCallback = null;\n\n        // set the initial parent\n        this.parent = particleParent;\n\n        if (config)\n        {\n            this.init(config);\n        }\n\n        // save often used functions on the instance instead of the prototype for better speed\n        this.recycle = this.recycle;\n        this.update = this.update;\n        this.rotate = this.rotate;\n        this.updateSpawnPos = this.updateSpawnPos;\n        this.updateOwnerPos = this.updateOwnerPos;\n    }\n\n    /**\n     * Time between particle spawns in seconds. If this value is not a number greater than 0,\n     * it will be set to 1 (particle per second) to prevent infinite loops.\n     */\n    public get frequency(): number { return this._frequency; }\n    public set frequency(value: number)\n    {\n        // do some error checking to prevent infinite loops\n        if (typeof value === 'number' && value > 0)\n        {\n            this._frequency = value;\n        }\n        else\n        {\n            this._frequency = 1;\n        }\n    }\n\n    /**\n    * The container to add particles to. Settings this will dump any active particles.\n    */\n    public get parent(): Container { return this._parent; }\n    public set parent(value: Container)\n    {\n        this.cleanup();\n        this._parent = value;\n    }\n\n    /**\n     * Sets up the emitter based on the config settings.\n     * @param config A configuration object containing settings for the emitter.\n     */\n    public init(config: EmitterConfigV3): void\n    {\n        if (!config)\n        {\n            return;\n        }\n        // clean up any existing particles\n        this.cleanup();\n\n        // store the original config and particle images, in case we need to re-initialize\n        // when the particle constructor is changed\n        this._origConfig = config;\n\n        // /////////////////////////\n        // Particle Properties    //\n        // /////////////////////////\n\n        // set up the lifetime\n        this.minLifetime = config.lifetime.min;\n        this.maxLifetime = config.lifetime.max;\n        // use the custom ease if provided\n        if (config.ease)\n        {\n            this.customEase = typeof config.ease === 'function'\n                ? config.ease : generateEase(config.ease);\n        }\n        else\n        {\n            this.customEase = null;\n        }\n        // ////////////////////////\n        // Emitter Properties    //\n        // ////////////////////////\n        // reset spawn type specific settings\n        this.particlesPerWave = 1;\n        if (config.particlesPerWave && config.particlesPerWave > 1)\n        {\n            this.particlesPerWave = config.particlesPerWave;\n        }\n        // set the spawning frequency\n        this.frequency = config.frequency;\n        this.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;\n        // set the emitter lifetime\n        this.emitterLifetime = config.emitterLifetime || -1;\n        // set the max particles\n        this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\n        // determine if we should add the particle at the back of the list or not\n        this.addAtBack = !!config.addAtBack;\n        // reset the emitter position and rotation variables\n        this.rotation = 0;\n        this.ownerPos.set(0);\n        if (config.pos)\n        {\n            this.spawnPos.copyFrom(config.pos);\n        }\n        else\n        {\n            this.spawnPos.set(0);\n        }\n\n        this._prevEmitterPos.copyFrom(this.spawnPos);\n        // previous emitter position is invalid and should not be used for interpolation\n        this._prevPosIsValid = false;\n        // start emitting\n        this._spawnTimer = 0;\n        this.emit = config.emit === undefined ? true : !!config.emit;\n        this.autoUpdate = !!config.autoUpdate;\n\n        // ////////////////////////\n        // Behaviors             //\n        // ////////////////////////\n        const behaviors: (IEmitterBehavior | typeof PositionParticle)[] = config.behaviors.map((data) =>\n        {\n            const constructor = Emitter.knownBehaviors[data.type];\n\n            if (!constructor)\n            {\n                console.error(`Unknown behavior: ${data.type}`);\n\n                return null;\n            }\n\n            return new constructor(data.config);\n        })\n            .filter((b) => !!b);\n\n        behaviors.push(PositionParticle);\n        behaviors.sort((a, b) =>\n        {\n            if (a === PositionParticle)\n            {\n                return (b as IEmitterBehavior).order === BehaviorOrder.Spawn ? 1 : -1;\n            }\n            else if (b === PositionParticle)\n            {\n                return (a as IEmitterBehavior).order === BehaviorOrder.Spawn ? -1 : 1;\n            }\n\n            return (a as IEmitterBehavior).order - (b as IEmitterBehavior).order;\n        });\n        this.initBehaviors = behaviors.slice();\n        this.updateBehaviors = behaviors.filter((b) => b !== PositionParticle && b.updateParticle) as IEmitterBehavior[];\n        this.recycleBehaviors = behaviors.filter((b) => b !== PositionParticle && b.recycleParticle) as IEmitterBehavior[];\n    }\n\n    /**\n     * Gets the instantiated behavior of the specified type, if it is present on this emitter.\n     * @param type The behavior type to find.\n     */\n    public getBehavior(type: string): IEmitterBehavior | null\n    {\n        // bail if we don't know about such an emitter\n        if (!Emitter.knownBehaviors[type]) return null;\n\n        // find one that is an instance of the specified type\n        return this.initBehaviors.find((b) => b instanceof Emitter.knownBehaviors[type]) as IEmitterBehavior || null;\n    }\n\n    /**\n     * Fills the pool with the specified number of particles, so that they don't have to be instantiated later.\n     * @param count The number of particles to create.\n     */\n    public fillPool(count: number): void\n    {\n        for (; count > 0; --count)\n        {\n            const p = new Particle(this);\n\n            p.next = this._poolFirst;\n            this._poolFirst = p;\n        }\n    }\n\n    /**\n     * Recycles an individual particle. For internal use only.\n     * @param particle The particle to recycle.\n     * @param fromCleanup If this is being called to manually clean up all particles.\n     * @internal\n     */\n    public recycle(particle: Particle, fromCleanup = false): void\n    {\n        for (let i = 0; i < this.recycleBehaviors.length; ++i)\n        {\n            this.recycleBehaviors[i].recycleParticle(particle, !fromCleanup);\n        }\n        if (particle.next)\n        {\n            particle.next.prev = particle.prev;\n        }\n        if (particle.prev)\n        {\n            particle.prev.next = particle.next;\n        }\n        if (particle === this._activeParticlesLast)\n        {\n            this._activeParticlesLast = particle.prev;\n        }\n        if (particle === this._activeParticlesFirst)\n        {\n            this._activeParticlesFirst = particle.next;\n        }\n        // add to pool\n        particle.prev = null;\n        particle.next = this._poolFirst;\n        this._poolFirst = particle;\n        // remove child from display, or make it invisible if it is in a ParticleContainer\n        if (particle.parent)\n        {\n            particle.parent.removeChild(particle);\n        }\n        // decrease count\n        --this.particleCount;\n    }\n\n    /**\n     * Sets the rotation of the emitter to a new value. This rotates the spawn position in addition\n     * to particle direction.\n     * @param newRot The new rotation, in degrees.\n     */\n    public rotate(newRot: number): void\n    {\n        if (this.rotation === newRot) return;\n        // caclulate the difference in rotation for rotating spawnPos\n        const diff = newRot - this.rotation;\n\n        this.rotation = newRot;\n        // rotate spawnPos\n        rotatePoint(diff, this.spawnPos);\n        // mark the position as having changed\n        this._posChanged = true;\n    }\n\n    /**\n     * Changes the spawn position of the emitter.\n     * @param x The new x value of the spawn position for the emitter.\n     * @param y The new y value of the spawn position for the emitter.\n     */\n    public updateSpawnPos(x: number, y: number): void\n    {\n        this._posChanged = true;\n        this.spawnPos.x = x;\n        this.spawnPos.y = y;\n    }\n\n    /**\n     * Changes the position of the emitter's owner. You should call this if you are adding\n     * particles to the world container that your emitter's owner is moving around in.\n     * @param x The new x value of the emitter's owner.\n     * @param y The new y value of the emitter's owner.\n     */\n    public updateOwnerPos(x: number, y: number): void\n    {\n        this._posChanged = true;\n        this.ownerPos.x = x;\n        this.ownerPos.y = y;\n    }\n\n    /**\n     * Prevents emitter position interpolation in the next update.\n     * This should be used if you made a major position change of your emitter's owner\n     * that was not normal movement.\n     */\n    public resetPositionTracking(): void\n    {\n        this._prevPosIsValid = false;\n    }\n\n    /**\n     * If particles should be emitted during update() calls. Setting this to false\n     * stops new particles from being created, but allows existing ones to die out.\n     */\n    public get emit(): boolean { return this._emit; }\n    public set emit(value: boolean)\n    {\n        this._emit = !!value;\n        this._emitterLife = this.emitterLifetime;\n    }\n\n    /**\n     * If the update function is called automatically from the shared ticker.\n     * Setting this to false requires calling the update function manually.\n     */\n    public get autoUpdate(): boolean { return this._autoUpdate; }\n    public set autoUpdate(value: boolean)\n    {\n        if (this._autoUpdate && !value)\n        {\n            ticker.remove(this.update, this);\n        }\n        else if (!this._autoUpdate && value)\n        {\n            ticker.add(this.update, this);\n        }\n        this._autoUpdate = !!value;\n    }\n\n    /**\n     * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\n     * when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    public playOnceAndDestroy(callback?: () => void): void\n    {\n        this.autoUpdate = true;\n        this.emit = true;\n        this._destroyWhenComplete = true;\n        this._completeCallback = callback;\n    }\n\n    /**\n     * Starts emitting particles and optionally calls a callback when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    public playOnce(callback?: () => void): void\n    {\n        this.emit = true;\n        this._completeCallback = callback;\n    }\n\n    /**\n     * Updates all particles spawned by this emitter and emits new ones.\n     * @param delta Time elapsed since the previous frame, in __seconds__.\n     */\n    public update(ticker: Ticker): void\n    {\n        let delta = ticker.deltaTime;\n\n        if (this._autoUpdate)\n        {\n            delta = ticker.elapsedMS * 0.001;\n        }\n\n        // if we don't have a parent to add particles to, then don't do anything.\n        // this also works as a isDestroyed check\n        if (!this._parent) return;\n\n        // == update existing particles ==\n\n        // update all particle lifetimes before turning them over to behaviors\n        for (let particle = this._activeParticlesFirst, next; particle; particle = next)\n        {\n            // save next particle in case we recycle this one\n            next = particle.next;\n            // increase age\n            particle.age += delta;\n            // recycle particle if it is too old\n            if (particle.age > particle.maxLife || particle.age < 0)\n            {\n                this.recycle(particle);\n            }\n            else\n            {\n                // determine our interpolation value\n                let lerp = particle.age * particle.oneOverLife;// lifetime / maxLife;\n\n                // global ease affects all interpolation calculations\n                if (this.customEase)\n                {\n                    if (this.customEase.length === 4)\n                    {\n                        // the t, b, c, d parameters that some tween libraries use\n                        // (time, initial value, end value, duration)\n                        lerp = (this.customEase as any)(lerp, 0, 1, 1);\n                    }\n                    else\n                    {\n                        // the simplified version that we like that takes\n                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                        lerp = this.customEase(lerp);\n                    }\n                }\n\n                // set age percent for all interpolation calculations\n                particle.agePercent = lerp;\n\n                // let each behavior run wild on the active particles\n                for (let i = 0; i < this.updateBehaviors.length; ++i)\n                {\n                    if (this.updateBehaviors[i].updateParticle(particle, delta))\n                    {\n                        this.recycle(particle);\n                        break;\n                    }\n                }\n            }\n        }\n\n        let prevX: number;\n        let prevY: number;\n\n        // if the previous position is valid, store these for later interpolation\n        if (this._prevPosIsValid)\n        {\n            prevX = this._prevEmitterPos.x;\n            prevY = this._prevEmitterPos.y;\n        }\n        // store current position of the emitter as local variables\n        const curX = this.ownerPos.x + this.spawnPos.x;\n        const curY = this.ownerPos.y + this.spawnPos.y;\n        // spawn new particles\n\n        if (this._emit)\n        {\n            // decrease spawn timer\n            this._spawnTimer -= delta < 0 ? 0 : delta;\n            // while _spawnTimer < 0, we have particles to spawn\n            while (this._spawnTimer <= 0)\n            {\n                // determine if the emitter should stop spawning\n                if (this._emitterLife >= 0)\n                {\n                    this._emitterLife -= this._frequency;\n                    if (this._emitterLife <= 0)\n                    {\n                        this._spawnTimer = 0;\n                        this._emitterLife = 0;\n                        this.emit = false;\n                        break;\n                    }\n                }\n                // determine if we have hit the particle limit\n                if (this.particleCount >= this.maxParticles)\n                {\n                    this._spawnTimer += this._frequency;\n                    continue;\n                }\n                let emitPosX: number;\n                let emitPosY: number;\n\n                // If the position has changed and this isn't the first spawn,\n                // interpolate the spawn position\n                if (this._prevPosIsValid && this._posChanged)\n                {\n                    // 1 - _spawnTimer / delta, but _spawnTimer is negative\n                    const lerp = 1 + (this._spawnTimer / delta);\n\n                    emitPosX = ((curX - prevX) * lerp) + prevX;\n                    emitPosY = ((curY - prevY) * lerp) + prevY;\n                }\n                // otherwise just set to the spawn position\n                else\n                {\n                    emitPosX = curX;\n                    emitPosY = curY;\n                }\n\n                let waveFirst: Particle = null;\n                let waveLast: Particle = null;\n\n                // create enough particles to fill the wave\n                for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i)\n                {\n                    // see if we actually spawn one\n                    if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n                    {\n                        continue;\n                    }\n                    // determine the particle lifetime\n                    let lifetime;\n\n                    if (this.minLifetime === this.maxLifetime)\n                    {\n                        lifetime = this.minLifetime;\n                    }\n                    else\n                    {\n                        lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n                    }\n                    // only make the particle if it wouldn't immediately destroy itself\n                    if (-this._spawnTimer >= lifetime)\n                    {\n                        continue;\n                    }\n                    // create particle\n                    let p: Particle;\n\n                    if (this._poolFirst)\n                    {\n                        p = this._poolFirst;\n                        this._poolFirst = this._poolFirst.next;\n                        p.next = null;\n                    }\n                    else\n                    {\n                        p = new Particle(this);\n                    }\n\n                    // initialize particle\n                    p.init(lifetime);\n                    // add the particle to the display list\n                    if (this.addAtBack)\n                    {\n                        this._parent.addChildAt(p, 0);\n                    }\n                    else\n                    {\n                        this._parent.addChild(p);\n                    }\n                    // add particles to list of ones in this wave\n                    if (waveFirst)\n                    {\n                        waveLast.next = p;\n                        p.prev = waveLast;\n                        waveLast = p;\n                    }\n                    else\n                    {\n                        waveLast = waveFirst = p;\n                    }\n                    // increase our particle count\n                    ++this.particleCount;\n                }\n\n                if (waveFirst)\n                {\n                    // add particle to list of active particles\n                    if (this._activeParticlesLast)\n                    {\n                        this._activeParticlesLast.next = waveFirst;\n                        waveFirst.prev = this._activeParticlesLast;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    else\n                    {\n                        this._activeParticlesFirst = waveFirst;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    // run behavior init on particles\n                    for (let i = 0; i < this.initBehaviors.length; ++i)\n                    {\n                        const behavior = this.initBehaviors[i];\n\n                        // if we hit our special key, interrupt behaviors to apply\n                        // emitter position/rotation\n                        if (behavior === PositionParticle)\n                        {\n                            for (let particle = waveFirst, next; particle; particle = next)\n                            {\n                                // save next particle in case we recycle this one\n                                next = particle.next;\n                                // rotate the particle's position by the emitter's rotation\n                                if (this.rotation !== 0)\n                                {\n                                    rotatePoint(this.rotation, particle.position);\n                                    particle.rotation += this.rotation;\n                                }\n                                // offset by the emitter's position\n                                particle.position.x += emitPosX;\n                                particle.position.y += emitPosY;\n\n                                // also, just update the particle's age properties while we are looping through\n                                particle.age += -this._spawnTimer;\n                                // determine our interpolation value\n                                let lerp = particle.age * particle.oneOverLife;// lifetime / maxLife;\n\n                                // global ease affects all interpolation calculations\n                                if (this.customEase)\n                                {\n                                    if (this.customEase.length === 4)\n                                    {\n                                        // the t, b, c, d parameters that some tween libraries use\n                                        // (time, initial value, end value, duration)\n                                        lerp = (this.customEase as any)(lerp, 0, 1, 1);\n                                    }\n                                    else\n                                    {\n                                        // the simplified version that we like that takes\n                                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                                        lerp = this.customEase(lerp);\n                                    }\n                                }\n                                // set age percent for all interpolation calculations\n                                particle.agePercent = lerp;\n                            }\n                        }\n                        else\n                        {\n                            behavior.initParticles(waveFirst);\n                        }\n                    }\n                    for (let particle = waveFirst, next; particle; particle = next)\n                    {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // now update the particles by the time passed, so the particles are spread out properly\n                        for (let i = 0; i < this.updateBehaviors.length; ++i)\n                        {\n                            // we want a positive delta, because a negative delta messes things up\n                            if (this.updateBehaviors[i].updateParticle(particle, -this._spawnTimer))\n                            {\n                                // bail if the particle got reycled\n                                this.recycle(particle);\n                                break;\n                            }\n                        }\n                    }\n                }\n                // increase timer and continue on to any other particles that need to be created\n                this._spawnTimer += this._frequency;\n            }\n        }\n        // if the position changed before this update, then keep track of that\n        if (this._posChanged)\n        {\n            this._prevEmitterPos.x = curX;\n            this._prevEmitterPos.y = curY;\n            this._prevPosIsValid = true;\n            this._posChanged = false;\n        }\n\n        // if we are all done and should destroy ourselves, take care of that\n        if (!this._emit && !this._activeParticlesFirst)\n        {\n            if (this._completeCallback)\n            {\n                const cb = this._completeCallback;\n\n                this._completeCallback = null;\n                cb();\n            }\n            if (this._destroyWhenComplete)\n            {\n                this.destroy();\n            }\n        }\n    }\n\n    /**\n     * Emits a single wave of particles, using standard spawnChance & particlesPerWave settings. Does not affect\n     * regular spawning through the frequency, and ignores the emit property. The max particle count is respected, however,\n     * so if there are already too many particles then nothing will happen.\n     */\n    public emitNow(): void\n    {\n        const emitPosX = this.ownerPos.x + this.spawnPos.x;\n        const emitPosY = this.ownerPos.y + this.spawnPos.y;\n\n        let waveFirst: Particle = null;\n        let waveLast: Particle = null;\n\n        // create enough particles to fill the wave\n        for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i)\n        {\n            // see if we actually spawn one\n            if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n            {\n                continue;\n            }\n            // create particle\n            let p: Particle;\n\n            if (this._poolFirst)\n            {\n                p = this._poolFirst;\n                this._poolFirst = this._poolFirst.next;\n                p.next = null;\n            }\n            else\n            {\n                p = new Particle(this);\n            }\n\n            let lifetime: number;\n\n            if (this.minLifetime === this.maxLifetime)\n            {\n                lifetime = this.minLifetime;\n            }\n            else\n            {\n                lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n            }\n            // initialize particle\n            p.init(lifetime);\n            // add the particle to the display list\n            if (this.addAtBack)\n            {\n                this._parent.addChildAt(p, 0);\n            }\n            else\n            {\n                this._parent.addChild(p);\n            }\n            // add particles to list of ones in this wave\n            if (waveFirst)\n            {\n                waveLast.next = p;\n                p.prev = waveLast;\n                waveLast = p;\n            }\n            else\n            {\n                waveLast = waveFirst = p;\n            }\n            // increase our particle count\n            ++this.particleCount;\n        }\n\n        if (waveFirst)\n        {\n            // add particle to list of active particles\n            if (this._activeParticlesLast)\n            {\n                this._activeParticlesLast.next = waveFirst;\n                waveFirst.prev = this._activeParticlesLast;\n                this._activeParticlesLast = waveLast;\n            }\n            else\n            {\n                this._activeParticlesFirst = waveFirst;\n                this._activeParticlesLast = waveLast;\n            }\n            // run behavior init on particles\n            for (let i = 0; i < this.initBehaviors.length; ++i)\n            {\n                const behavior = this.initBehaviors[i];\n\n                // if we hit our special key, interrupt behaviors to apply\n                // emitter position/rotation\n                if (behavior === PositionParticle)\n                {\n                    for (let particle = waveFirst, next; particle; particle = next)\n                    {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // rotate the particle's position by the emitter's rotation\n                        if (this.rotation !== 0)\n                        {\n                            rotatePoint(this.rotation, particle.position);\n                            particle.rotation += this.rotation;\n                        }\n                        // offset by the emitter's position\n                        particle.position.x += emitPosX;\n                        particle.position.y += emitPosY;\n                    }\n                }\n                else\n                {\n                    behavior.initParticles(waveFirst);\n                }\n            }\n        }\n    }\n\n    /**\n     * Kills all active particles immediately.\n     */\n    public cleanup(): void\n    {\n        let particle;\n        let next;\n\n        for (particle = this._activeParticlesFirst; particle; particle = next)\n        {\n            next = particle.next;\n            this.recycle(particle, true);\n        }\n        this._activeParticlesFirst = this._activeParticlesLast = null;\n        this.particleCount = 0;\n    }\n\n    /**\n     * If this emitter has been destroyed. Note that a destroyed emitter can still be reused, after\n     * having a new parent set and being reinitialized.\n     */\n    public get destroyed(): boolean\n    {\n        return !(this._parent && this.initBehaviors.length);\n    }\n\n    /**\n     * Destroys the emitter and all of its particles.\n     */\n    public destroy(): void\n    {\n        // make sure we aren't still listening to any tickers\n        this.autoUpdate = false;\n        // puts all active particles in the pool, and removes them from the particle parent\n        this.cleanup();\n        // wipe the pool clean\n        let next;\n\n        for (let particle = this._poolFirst; particle; particle = next)\n        {\n            // store next value so we don't lose it in our destroy call\n            next = particle.next;\n            particle.destroy();\n        }\n        this._poolFirst = this._parent = this.spawnPos = this.ownerPos\n            = this.customEase = this._completeCallback = null;\n\n        this.initBehaviors.length = this.updateBehaviors.length = this.recycleBehaviors.length = 0;\n    }\n}\n","import * as behaviors from './behaviors';\nimport { Emitter } from './Emitter';\n\nEmitter.registerBehavior(behaviors.AccelerationBehavior);\nEmitter.registerBehavior(behaviors.AlphaBehavior);\nEmitter.registerBehavior(behaviors.StaticAlphaBehavior);\nEmitter.registerBehavior(behaviors.RandomAnimatedTextureBehavior);\nEmitter.registerBehavior(behaviors.SingleAnimatedTextureBehavior);\nEmitter.registerBehavior(behaviors.BlendModeBehavior);\nEmitter.registerBehavior(behaviors.BurstSpawnBehavior);\nEmitter.registerBehavior(behaviors.ColorBehavior);\nEmitter.registerBehavior(behaviors.StaticColorBehavior);\nEmitter.registerBehavior(behaviors.OrderedTextureBehavior);\nEmitter.registerBehavior(behaviors.PathBehavior);\nEmitter.registerBehavior(behaviors.PointSpawnBehavior);\nEmitter.registerBehavior(behaviors.RandomTextureBehavior);\nEmitter.registerBehavior(behaviors.RotationBehavior);\nEmitter.registerBehavior(behaviors.StaticRotationBehavior);\nEmitter.registerBehavior(behaviors.NoRotationBehavior);\nEmitter.registerBehavior(behaviors.ScaleBehavior);\nEmitter.registerBehavior(behaviors.StaticScaleBehavior);\nEmitter.registerBehavior(behaviors.ShapeSpawnBehavior);\nEmitter.registerBehavior(behaviors.SingleTextureBehavior);\nEmitter.registerBehavior(behaviors.SpeedBehavior);\nEmitter.registerBehavior(behaviors.StaticSpeedBehavior);\n\nexport * as behaviors from './behaviors';\nexport * from './Emitter';\nexport * from './EmitterConfig';\nexport * from './LinkedListChild';\nexport * from './Particle';\nexport * as ParticleUtils from './ParticleUtils';\nexport * from './PropertyList';\nexport * from './PropertyNode';\n","/* eslint-disable no-lonely-if */\nimport { PointData } from 'pixi.js';\nimport { EaseSegment, SimpleEase } from './ParticleUtils';\nimport { ValueList } from './PropertyNode';\n\n/**\n * Full Emitter configuration for initializing an Emitter instance.\n */\nexport interface EmitterConfigV3\n{\n    /**\n     * Random number configuration for picking the lifetime for each particle..\n     */\n    lifetime: RandNumber;\n    /**\n     * Easing to be applied to all interpolated or stepped values across the particle lifetime.\n     */\n    ease?: SimpleEase | EaseSegment[];\n    /**\n     * How many particles to spawn at once, each time that it is determined that particles should be spawned.\n     * If omitted, only one particle will spawn at a time.\n     */\n    particlesPerWave?: number;\n    /**\n     * How often to spawn particles. This is a value in seconds, so a value of 0.5 would be twice a second.\n     */\n    frequency: number;\n    /**\n     * Defines a chance to not spawn particles. Values lower than 1 mean particles may not be spawned each time.\n     * If omitted, particles will always spawn.\n     */\n    spawnChance?: number;\n    /**\n     * How long to run the Emitter before it stops spawning particles. If omitted, runs forever (or until told to stop\n     * manually).\n     */\n    emitterLifetime?: number;\n    /**\n     * Maximum number of particles that can be alive at any given time for this emitter.\n     */\n    maxParticles?: number;\n    /**\n     * If newly spawned particles should be added to the back of the parent container (to make them less conspicuous\n     * as they pop in). If omitted, particles will be added to the top of the container.\n     */\n    addAtBack?: boolean;\n    /**\n     * Default position to spawn particles from inside the parent container.\n     */\n    pos: { x: number; y: number };\n    /**\n     * If the emitter should start out emitting particles. If omitted, it will be treated as `true` and will emit particles\n     * immediately.\n     */\n    emit?: boolean;\n    /**\n     * If the Emitter should hook into PixiJS's shared ticker. If this is false or emitted, you will be responsible for\n     * connecting it to update ticks.\n     */\n    autoUpdate?: boolean;\n\n    /**\n     * The list of behaviors to apply to this emitter. See the behaviors namespace for\n     * a list of built in behaviors. Custom behaviors may be registered with {@link Emitter.registerBehavior}.\n     */\n    behaviors: BehaviorEntry[];\n}\n\n/**\n * See {@link EmitterConfigV3.behaviors}\n */\nexport interface BehaviorEntry\n{\n    /**\n     * The behavior type, as defined as the static `type` property of a behavior class.\n     */\n    type: string;\n    /**\n     * Configuration data specific to that behavior.\n     */\n    config: any;\n}\n\n/**\n * Configuration for how to pick a random number (inclusive).\n */\nexport interface RandNumber\n{\n    /**\n     * Maximum pickable value.\n     */\n    max: number;\n    /**\n     * Minimum pickable value.\n     */\n    min: number;\n}\n\n/**\n * Converts emitter configuration from pre-5.0.0 library values into the current version.\n *\n * Example usage:\n * ```javascript\n * const emitter = new Emitter(myContainer, upgradeConfig(myOldConfig, [myTexture, myOtherTexture]));\n * ```\n * @param config The old emitter config to upgrade.\n * @param art The old art values as would have been passed into the Emitter constructor or `Emitter.init()`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function upgradeConfig(config: EmitterConfigV2 | EmitterConfigV1 | EmitterConfigV3, art: any): EmitterConfigV3\n{\n    // just ensure we aren't given any V3 config data\n    if ('behaviors' in config)\n    {\n        return config;\n    }\n\n    const out: EmitterConfigV3 = {\n        lifetime: config.lifetime,\n        ease: config.ease,\n        particlesPerWave: config.particlesPerWave,\n        frequency: config.frequency,\n        spawnChance: config.spawnChance,\n        emitterLifetime: config.emitterLifetime,\n        maxParticles: config.maxParticles,\n        addAtBack: config.addAtBack,\n        pos: config.pos,\n        emit: config.emit,\n        autoUpdate: config.autoUpdate,\n        behaviors: [],\n    };\n\n    // set up the alpha\n    if (config.alpha)\n    {\n        if ('start' in config.alpha)\n        {\n            if (config.alpha.start === config.alpha.end)\n            {\n                if (config.alpha.start !== 1)\n                {\n                    out.behaviors.push({\n                        type: 'alphaStatic',\n                        config: { alpha: config.alpha.start },\n                    });\n                }\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.alpha.start },\n                        { time: 1, value: config.alpha.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'alpha',\n                    config: { alpha: list },\n                });\n            }\n        }\n        else if (config.alpha.list.length === 1)\n        {\n            if (config.alpha.list[0].value !== 1)\n            {\n                out.behaviors.push({\n                    type: 'alphaStatic',\n                    config: { alpha: config.alpha.list[0].value },\n                });\n            }\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'alpha',\n                config: { alpha: config.alpha },\n            });\n        }\n    }\n\n    // acceleration movement\n    if (config.acceleration && (config.acceleration.x || config.acceleration.y))\n    {\n        let minStart: number;\n        let maxStart: number;\n\n        if ('start' in config.speed)\n        {\n            minStart = config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.start;\n        }\n        else\n        {\n            minStart = config.speed.list[0].value * ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.list[0].value;\n        }\n\n        out.behaviors.push({\n            type: 'moveAcceleration',\n            config: {\n                accel: config.acceleration,\n                minStart,\n                maxStart,\n                rotate: !config.noRotation,\n                maxSpeed: config.maxSpeed,\n            },\n        });\n    }\n    // path movement\n    else if (config.extraData?.path)\n    {\n        let list: ValueList<number>;\n        let mult: number;\n\n        if ('start' in config.speed)\n        {\n            mult = config.speed.minimumSpeedMultiplier ?? 1;\n            if (config.speed.start === config.speed.end)\n            {\n                list = {\n                    list: [{ time: 0, value: config.speed.start }],\n                };\n            }\n            else\n            {\n                list = {\n                    list: [\n                        { time: 0, value: config.speed.start },\n                        { time: 1, value: config.speed.end },\n                    ],\n                };\n            }\n        }\n        else\n        {\n            list = config.speed;\n            mult = ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1);\n        }\n\n        out.behaviors.push({\n            type: 'movePath',\n            config: {\n                path: config.extraData.path,\n                speed: list,\n                minMult: mult,\n            },\n        });\n    }\n    // normal speed movement\n    else\n    {\n        if (config.speed)\n        {\n            if ('start' in config.speed)\n            {\n                if (config.speed.start === config.speed.end)\n                {\n                    out.behaviors.push({\n                        type: 'moveSpeedStatic',\n                        config: {\n                            min: config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1),\n                            max: config.speed.start,\n                        },\n                    });\n                }\n                else\n                {\n                    const list: ValueList<number> = {\n                        list: [\n                            { time: 0, value: config.speed.start },\n                            { time: 1, value: config.speed.end },\n                        ],\n                    };\n\n                    out.behaviors.push({\n                        type: 'moveSpeed',\n                        config: { speed: list, minMult: config.speed.minimumSpeedMultiplier },\n                    });\n                }\n            }\n            else if (config.speed.list.length === 1)\n            {\n                out.behaviors.push({\n                    type: 'moveSpeedStatic',\n                    config: {\n                        min: config.speed.list[0].value * ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1),\n                        max: config.speed.list[0].value,\n                    },\n                });\n            }\n            else\n            {\n                out.behaviors.push({\n                    type: 'moveSpeed',\n                    config: { speed: config.speed, minMult: ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1) },\n                });\n            }\n        }\n    }\n\n    // scale\n    if (config.scale)\n    {\n        if ('start' in config.scale)\n        {\n            const mult = config.scale.minimumScaleMultiplier ?? 1;\n\n            if (config.scale.start === config.scale.end)\n            {\n                out.behaviors.push({\n                    type: 'scaleStatic',\n                    config: {\n                        min: config.scale.start * mult,\n                        max: config.scale.start,\n                    },\n                });\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.scale.start },\n                        { time: 1, value: config.scale.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'scale',\n                    config: { scale: list, minMult: mult },\n                });\n            }\n        }\n        else if (config.scale.list.length === 1)\n        {\n            const mult = (config as EmitterConfigV2).minimumScaleMultiplier ?? 1;\n            const scale = config.scale.list[0].value;\n\n            out.behaviors.push({\n                type: 'scaleStatic',\n                config: { min: scale * mult, max: scale },\n            });\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'scale',\n                config: { scale: config.scale, minMult: (config as EmitterConfigV2).minimumScaleMultiplier ?? 1 },\n            });\n        }\n    }\n\n    // color\n    if (config.color)\n    {\n        if ('start' in config.color)\n        {\n            if (config.color.start === config.color.end)\n            {\n                if (config.color.start !== 'ffffff')\n                {\n                    out.behaviors.push({\n                        type: 'colorStatic',\n                        config: { color: config.color.start },\n                    });\n                }\n            }\n            else\n            {\n                const list: ValueList<string> = {\n                    list: [\n                        { time: 0, value: config.color.start },\n                        { time: 1, value: config.color.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'color',\n                    config: { color: list },\n                });\n            }\n        }\n        else if (config.color.list.length === 1)\n        {\n            if (config.color.list[0].value !== 'ffffff')\n            {\n                out.behaviors.push({\n                    type: 'colorStatic',\n                    config: { color: config.color.list[0].value },\n                });\n            }\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'color',\n                config: { color: config.color },\n            });\n        }\n    }\n\n    // rotation\n    if (config.rotationAcceleration || config.rotationSpeed?.min || config.rotationSpeed?.max)\n    {\n        out.behaviors.push({\n            type: 'rotation',\n            config: {\n                accel: config.rotationAcceleration || 0,\n                minSpeed: config.rotationSpeed?.min || 0,\n                maxSpeed: config.rotationSpeed?.max || 0,\n                minStart: config.startRotation?.min || 0,\n                maxStart: config.startRotation?.max || 0,\n            },\n        });\n    }\n    else if (config.startRotation?.min || config.startRotation?.max)\n    {\n        out.behaviors.push({\n            type: 'rotationStatic',\n            config: {\n                min: config.startRotation?.min || 0,\n                max: config.startRotation?.max || 0,\n            },\n        });\n    }\n    if (config.noRotation)\n    {\n        out.behaviors.push({\n            type: 'noRotation',\n            config: {},\n        });\n    }\n\n    // blend mode\n    if (config.blendMode && config.blendMode !== 'normal')\n    {\n        out.behaviors.push({\n            type: 'blendMode',\n            config: {\n                blendMode: config.blendMode,\n            },\n        });\n    }\n\n    // animated\n    if (Array.isArray(art) && typeof art[0] !== 'string' && 'framerate' in art[0])\n    {\n        for (let i = 0; i < art.length; ++i)\n        {\n            if (art[i].framerate === 'matchLife')\n            {\n                art[i].framerate = -1;\n            }\n        }\n        out.behaviors.push({\n            type: 'animatedRandom',\n            config: {\n                anims: art,\n            },\n        });\n    }\n    else if (typeof art !== 'string' && 'framerate' in art)\n    {\n        if (art.framerate === 'matchLife')\n        {\n            art.framerate = -1;\n        }\n        out.behaviors.push({\n            type: 'animatedSingle',\n            config: {\n                anim: art,\n            },\n        });\n    }\n    // ordered art\n    else if (config.orderedArt && Array.isArray(art))\n    {\n        out.behaviors.push({\n            type: 'textureOrdered',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // random texture\n    else if (Array.isArray(art))\n    {\n        out.behaviors.push({\n            type: 'textureRandom',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // single texture\n    else\n    {\n        out.behaviors.push({\n            type: 'textureSingle',\n            config: {\n                texture: art,\n            },\n        });\n    }\n\n    // spawn burst\n    if (config.spawnType === 'burst')\n    {\n        out.behaviors.push({\n            type: 'spawnBurst',\n            config: {\n                start: config.angleStart || 0,\n                spacing: config.particleSpacing,\n                // older formats bursted from a single point\n                distance: 0,\n            },\n        });\n    }\n    // spawn point\n    else if (config.spawnType === 'point')\n    {\n        out.behaviors.push({\n            type: 'spawnPoint',\n            config: {},\n        });\n    }\n    // spawn shape\n    else\n    {\n        let shape: any;\n\n        if (config.spawnType === 'ring')\n        {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: config.spawnCircle.minR,\n                    affectRotation: true,\n                },\n            };\n        }\n        else if (config.spawnType === 'circle')\n        {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: 0,\n                    affectRotation: false,\n                },\n            };\n        }\n        else if (config.spawnType === 'rect')\n        {\n            shape = {\n                type: 'rect',\n                data: config.spawnRect,\n            };\n        }\n        else if (config.spawnType === 'polygonalChain')\n        {\n            shape = {\n                type: 'polygonalChain',\n                data: config.spawnPolygon,\n            };\n        }\n\n        if (shape)\n        {\n            out.behaviors.push({\n                type: 'spawnShape',\n                config: shape,\n            });\n        }\n    }\n\n    return out;\n}\n\n/**\n * The obsolete emitter configuration format from version 3.0.0 of the library.\n * This type information is kept to make it easy to upgrade, but otherwise\n * configuration should be made as {@link EmitterConfigV3}.\n */\nexport interface EmitterConfigV2\n{\n    alpha?: ValueList<number>;\n    speed?: ValueList<number>;\n    minimumSpeedMultiplier?: number;\n    maxSpeed?: number;\n    acceleration?: {x: number; y: number};\n    scale?: ValueList<number>;\n    minimumScaleMultiplier?: number;\n    color?: ValueList<string>;\n    startRotation?: RandNumber;\n    noRotation?: boolean;\n    rotationSpeed?: RandNumber;\n    rotationAcceleration?: number;\n    lifetime: RandNumber;\n    blendMode?: string;\n    ease?: SimpleEase | EaseSegment[];\n    extraData?: any;\n    particlesPerWave?: number;\n    /**\n     * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\n     * tends to be too strict for random object creation.\n     */\n    spawnType?: string;\n    spawnRect?: {x: number; y: number; w: number; h: number};\n    spawnCircle?: {x: number; y: number; r: number; minR?: number};\n    particleSpacing?: number;\n    angleStart?: number;\n    spawnPolygon?: PointData[] | PointData[][];\n    frequency: number;\n    spawnChance?: number;\n    emitterLifetime?: number;\n    maxParticles?: number;\n    addAtBack?: boolean;\n    pos: {x: number; y: number};\n    emit?: boolean;\n    autoUpdate?: boolean;\n    orderedArt?: boolean;\n}\n\nexport interface BasicTweenable<T>\n{\n    start: T;\n    end: T;\n}\n\n/**\n * The obsolete emitter configuration format of the initial library release.\n * This type information is kept to maintain compatibility with the older particle tool, but otherwise\n * configuration should be made as {@link EmitterConfigV3}.\n */\nexport interface EmitterConfigV1\n{\n    alpha?: BasicTweenable<number>;\n    speed?: BasicTweenable<number> & {minimumSpeedMultiplier?: number};\n    maxSpeed?: number;\n    acceleration?: {x: number; y: number};\n    scale?: BasicTweenable<number> & {minimumScaleMultiplier?: number};\n    color?: BasicTweenable<string>;\n    startRotation?: RandNumber;\n    noRotation?: boolean;\n    rotationSpeed?: RandNumber;\n    rotationAcceleration?: number;\n    lifetime: RandNumber;\n    blendMode?: string;\n    ease?: SimpleEase | EaseSegment[];\n    extraData?: any;\n    particlesPerWave?: number;\n    /**\n     * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\n     * tends to be too strict for random object creation.\n     */\n    spawnType?: string;\n    spawnRect?: {x: number; y: number; w: number; h: number};\n    spawnCircle?: {x: number; y: number; r: number; minR?: number};\n    particleSpacing?: number;\n    angleStart?: number;\n    spawnPolygon?: PointData[] | PointData[][];\n    frequency: number;\n    spawnChance?: number;\n    emitterLifetime?: number;\n    maxParticles?: number;\n    addAtBack?: boolean;\n    pos: {x: number; y: number};\n    emit?: boolean;\n    autoUpdate?: boolean;\n    orderedArt?: boolean;\n}\n"],"mappings":"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"}